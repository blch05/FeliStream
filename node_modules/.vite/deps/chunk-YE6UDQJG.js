var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/queue-tick/queue-microtask.js
var require_queue_microtask = __commonJS({
  "node_modules/queue-tick/queue-microtask.js"(exports, module) {
    module.exports = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => Promise.resolve().then(fn);
  }
});

// node_modules/fast-fifo/fixed-size.js
var require_fixed_size = __commonJS({
  "node_modules/fast-fifo/fixed-size.js"(exports, module) {
    module.exports = class FixedFIFO {
      constructor(hwm) {
        if (!(hwm > 0) || (hwm - 1 & hwm) !== 0) throw new Error("Max size for a FixedFIFO should be a power of two");
        this.buffer = new Array(hwm);
        this.mask = hwm - 1;
        this.top = 0;
        this.btm = 0;
        this.next = null;
      }
      clear() {
        this.top = this.btm = 0;
        this.next = null;
        this.buffer.fill(void 0);
      }
      push(data) {
        if (this.buffer[this.top] !== void 0) return false;
        this.buffer[this.top] = data;
        this.top = this.top + 1 & this.mask;
        return true;
      }
      shift() {
        const last = this.buffer[this.btm];
        if (last === void 0) return void 0;
        this.buffer[this.btm] = void 0;
        this.btm = this.btm + 1 & this.mask;
        return last;
      }
      peek() {
        return this.buffer[this.btm];
      }
      isEmpty() {
        return this.buffer[this.btm] === void 0;
      }
    };
  }
});

// node_modules/fast-fifo/index.js
var require_fast_fifo = __commonJS({
  "node_modules/fast-fifo/index.js"(exports, module) {
    var FixedFIFO = require_fixed_size();
    module.exports = class FastFIFO {
      constructor(hwm) {
        this.hwm = hwm || 16;
        this.head = new FixedFIFO(this.hwm);
        this.tail = this.head;
        this.length = 0;
      }
      clear() {
        this.head = this.tail;
        this.head.clear();
        this.length = 0;
      }
      push(val) {
        this.length++;
        if (!this.head.push(val)) {
          const prev = this.head;
          this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
          this.head.push(val);
        }
      }
      shift() {
        if (this.length !== 0) this.length--;
        const val = this.tail.shift();
        if (val === void 0 && this.tail.next) {
          const next = this.tail.next;
          this.tail.next = null;
          this.tail = next;
          return this.tail.shift();
        }
        return val;
      }
      peek() {
        const val = this.tail.peek();
        if (val === void 0 && this.tail.next) return this.tail.next.peek();
        return val;
      }
      isEmpty() {
        return this.length === 0;
      }
    };
  }
});

// node_modules/text-decoder/lib/browser-decoder.js
var require_browser_decoder = __commonJS({
  "node_modules/text-decoder/lib/browser-decoder.js"(exports, module) {
    module.exports = class BrowserDecoder {
      constructor(encoding) {
        this.decoder = new TextDecoder(encoding === "utf16le" ? "utf16-le" : encoding);
      }
      get remaining() {
        return -1;
      }
      decode(data) {
        return this.decoder.decode(data, { stream: true });
      }
      flush() {
        return this.decoder.decode(new Uint8Array(0));
      }
    };
  }
});

// node_modules/text-decoder/index.js
var require_text_decoder = __commonJS({
  "node_modules/text-decoder/index.js"(exports, module) {
    var PassThroughDecoder = require_browser_decoder();
    var UTF8Decoder = require_browser_decoder();
    module.exports = class TextDecoder {
      constructor(encoding = "utf8") {
        this.encoding = normalizeEncoding(encoding);
        switch (this.encoding) {
          case "utf8":
            this.decoder = new UTF8Decoder();
            break;
          case "utf16le":
          case "base64":
            throw new Error("Unsupported encoding: " + this.encoding);
          default:
            this.decoder = new PassThroughDecoder(this.encoding);
        }
      }
      get remaining() {
        return this.decoder.remaining;
      }
      push(data) {
        if (typeof data === "string") return data;
        return this.decoder.decode(data);
      }
      // For Node.js compatibility
      write(data) {
        return this.push(data);
      }
      end(data) {
        let result = "";
        if (data) result = this.push(data);
        result += this.decoder.flush();
        return result;
      }
    };
    function normalizeEncoding(encoding) {
      encoding = encoding.toLowerCase();
      switch (encoding) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return encoding;
        default:
          throw new Error("Unknown encoding: " + encoding);
      }
    }
  }
});

// node_modules/streamx/index.js
var require_streamx = __commonJS({
  "node_modules/streamx/index.js"(exports, module) {
    var { EventEmitter: EventEmitter2 } = require_events();
    var STREAM_DESTROYED = new Error("Stream was destroyed");
    var PREMATURE_CLOSE = new Error("Premature close");
    var queueTick = require_queue_microtask();
    var FIFO = require_fast_fifo();
    var TextDecoder2 = require_text_decoder();
    var MAX = (1 << 29) - 1;
    var OPENING = 1;
    var PREDESTROYING = 2;
    var DESTROYING = 4;
    var DESTROYED = 8;
    var NOT_OPENING = MAX ^ OPENING;
    var NOT_PREDESTROYING = MAX ^ PREDESTROYING;
    var READ_ACTIVE = 1 << 4;
    var READ_UPDATING = 2 << 4;
    var READ_PRIMARY = 4 << 4;
    var READ_QUEUED = 8 << 4;
    var READ_RESUMED = 16 << 4;
    var READ_PIPE_DRAINED = 32 << 4;
    var READ_ENDING = 64 << 4;
    var READ_EMIT_DATA = 128 << 4;
    var READ_EMIT_READABLE = 256 << 4;
    var READ_EMITTED_READABLE = 512 << 4;
    var READ_DONE = 1024 << 4;
    var READ_NEXT_TICK = 2048 << 4;
    var READ_NEEDS_PUSH = 4096 << 4;
    var READ_READ_AHEAD = 8192 << 4;
    var READ_FLOWING = READ_RESUMED | READ_PIPE_DRAINED;
    var READ_ACTIVE_AND_NEEDS_PUSH = READ_ACTIVE | READ_NEEDS_PUSH;
    var READ_PRIMARY_AND_ACTIVE = READ_PRIMARY | READ_ACTIVE;
    var READ_EMIT_READABLE_AND_QUEUED = READ_EMIT_READABLE | READ_QUEUED;
    var READ_RESUMED_READ_AHEAD = READ_RESUMED | READ_READ_AHEAD;
    var READ_NOT_ACTIVE = MAX ^ READ_ACTIVE;
    var READ_NON_PRIMARY = MAX ^ READ_PRIMARY;
    var READ_NON_PRIMARY_AND_PUSHED = MAX ^ (READ_PRIMARY | READ_NEEDS_PUSH);
    var READ_PUSHED = MAX ^ READ_NEEDS_PUSH;
    var READ_PAUSED = MAX ^ READ_RESUMED;
    var READ_NOT_QUEUED = MAX ^ (READ_QUEUED | READ_EMITTED_READABLE);
    var READ_NOT_ENDING = MAX ^ READ_ENDING;
    var READ_PIPE_NOT_DRAINED = MAX ^ READ_FLOWING;
    var READ_NOT_NEXT_TICK = MAX ^ READ_NEXT_TICK;
    var READ_NOT_UPDATING = MAX ^ READ_UPDATING;
    var READ_NO_READ_AHEAD = MAX ^ READ_READ_AHEAD;
    var READ_PAUSED_NO_READ_AHEAD = MAX ^ READ_RESUMED_READ_AHEAD;
    var WRITE_ACTIVE = 1 << 18;
    var WRITE_UPDATING = 2 << 18;
    var WRITE_PRIMARY = 4 << 18;
    var WRITE_QUEUED = 8 << 18;
    var WRITE_UNDRAINED = 16 << 18;
    var WRITE_DONE = 32 << 18;
    var WRITE_EMIT_DRAIN = 64 << 18;
    var WRITE_NEXT_TICK = 128 << 18;
    var WRITE_WRITING = 256 << 18;
    var WRITE_FINISHING = 512 << 18;
    var WRITE_CORKED = 1024 << 18;
    var WRITE_NOT_ACTIVE = MAX ^ (WRITE_ACTIVE | WRITE_WRITING);
    var WRITE_NON_PRIMARY = MAX ^ WRITE_PRIMARY;
    var WRITE_NOT_FINISHING = MAX ^ WRITE_FINISHING;
    var WRITE_DRAINED = MAX ^ WRITE_UNDRAINED;
    var WRITE_NOT_QUEUED = MAX ^ WRITE_QUEUED;
    var WRITE_NOT_NEXT_TICK = MAX ^ WRITE_NEXT_TICK;
    var WRITE_NOT_UPDATING = MAX ^ WRITE_UPDATING;
    var WRITE_NOT_CORKED = MAX ^ WRITE_CORKED;
    var ACTIVE = READ_ACTIVE | WRITE_ACTIVE;
    var NOT_ACTIVE = MAX ^ ACTIVE;
    var DONE = READ_DONE | WRITE_DONE;
    var DESTROY_STATUS = DESTROYING | DESTROYED | PREDESTROYING;
    var OPEN_STATUS = DESTROY_STATUS | OPENING;
    var AUTO_DESTROY = DESTROY_STATUS | DONE;
    var NON_PRIMARY = WRITE_NON_PRIMARY & READ_NON_PRIMARY;
    var ACTIVE_OR_TICKING = WRITE_NEXT_TICK | READ_NEXT_TICK;
    var TICKING = ACTIVE_OR_TICKING & NOT_ACTIVE;
    var IS_OPENING = OPEN_STATUS | TICKING;
    var READ_PRIMARY_STATUS = OPEN_STATUS | READ_ENDING | READ_DONE;
    var READ_STATUS = OPEN_STATUS | READ_DONE | READ_QUEUED;
    var READ_ENDING_STATUS = OPEN_STATUS | READ_ENDING | READ_QUEUED;
    var READ_READABLE_STATUS = OPEN_STATUS | READ_EMIT_READABLE | READ_QUEUED | READ_EMITTED_READABLE;
    var SHOULD_NOT_READ = OPEN_STATUS | READ_ACTIVE | READ_ENDING | READ_DONE | READ_NEEDS_PUSH | READ_READ_AHEAD;
    var READ_BACKPRESSURE_STATUS = DESTROY_STATUS | READ_ENDING | READ_DONE;
    var READ_UPDATE_SYNC_STATUS = READ_UPDATING | OPEN_STATUS | READ_NEXT_TICK | READ_PRIMARY;
    var WRITE_PRIMARY_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_DONE;
    var WRITE_QUEUED_AND_UNDRAINED = WRITE_QUEUED | WRITE_UNDRAINED;
    var WRITE_QUEUED_AND_ACTIVE = WRITE_QUEUED | WRITE_ACTIVE;
    var WRITE_DRAIN_STATUS = WRITE_QUEUED | WRITE_UNDRAINED | OPEN_STATUS | WRITE_ACTIVE;
    var WRITE_STATUS = OPEN_STATUS | WRITE_ACTIVE | WRITE_QUEUED | WRITE_CORKED;
    var WRITE_PRIMARY_AND_ACTIVE = WRITE_PRIMARY | WRITE_ACTIVE;
    var WRITE_ACTIVE_AND_WRITING = WRITE_ACTIVE | WRITE_WRITING;
    var WRITE_FINISHING_STATUS = OPEN_STATUS | WRITE_FINISHING | WRITE_QUEUED_AND_ACTIVE | WRITE_DONE;
    var WRITE_BACKPRESSURE_STATUS = WRITE_UNDRAINED | DESTROY_STATUS | WRITE_FINISHING | WRITE_DONE;
    var WRITE_UPDATE_SYNC_STATUS = WRITE_UPDATING | OPEN_STATUS | WRITE_NEXT_TICK | WRITE_PRIMARY;
    var asyncIterator = Symbol.asyncIterator || Symbol("asyncIterator");
    var WritableState = class {
      constructor(stream, { highWaterMark = 16384, map = null, mapWritable, byteLength, byteLengthWritable } = {}) {
        this.stream = stream;
        this.queue = new FIFO();
        this.highWaterMark = highWaterMark;
        this.buffered = 0;
        this.error = null;
        this.pipeline = null;
        this.drains = null;
        this.byteLength = byteLengthWritable || byteLength || defaultByteLength;
        this.map = mapWritable || map;
        this.afterWrite = afterWrite.bind(this);
        this.afterUpdateNextTick = updateWriteNT.bind(this);
      }
      get ended() {
        return (this.stream._duplexState & WRITE_DONE) !== 0;
      }
      push(data) {
        if (this.map !== null) data = this.map(data);
        this.buffered += this.byteLength(data);
        this.queue.push(data);
        if (this.buffered < this.highWaterMark) {
          this.stream._duplexState |= WRITE_QUEUED;
          return true;
        }
        this.stream._duplexState |= WRITE_QUEUED_AND_UNDRAINED;
        return false;
      }
      shift() {
        const data = this.queue.shift();
        this.buffered -= this.byteLength(data);
        if (this.buffered === 0) this.stream._duplexState &= WRITE_NOT_QUEUED;
        return data;
      }
      end(data) {
        if (typeof data === "function") this.stream.once("finish", data);
        else if (data !== void 0 && data !== null) this.push(data);
        this.stream._duplexState = (this.stream._duplexState | WRITE_FINISHING) & WRITE_NON_PRIMARY;
      }
      autoBatch(data, cb) {
        const buffer = [];
        const stream = this.stream;
        buffer.push(data);
        while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED_AND_ACTIVE) {
          buffer.push(stream._writableState.shift());
        }
        if ((stream._duplexState & OPEN_STATUS) !== 0) return cb(null);
        stream._writev(buffer, cb);
      }
      update() {
        const stream = this.stream;
        stream._duplexState |= WRITE_UPDATING;
        do {
          while ((stream._duplexState & WRITE_STATUS) === WRITE_QUEUED) {
            const data = this.shift();
            stream._duplexState |= WRITE_ACTIVE_AND_WRITING;
            stream._write(data, this.afterWrite);
          }
          if ((stream._duplexState & WRITE_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();
        } while (this.continueUpdate() === true);
        stream._duplexState &= WRITE_NOT_UPDATING;
      }
      updateNonPrimary() {
        const stream = this.stream;
        if ((stream._duplexState & WRITE_FINISHING_STATUS) === WRITE_FINISHING) {
          stream._duplexState = (stream._duplexState | WRITE_ACTIVE) & WRITE_NOT_FINISHING;
          stream._final(afterFinal.bind(this));
          return;
        }
        if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
          if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
            stream._duplexState |= ACTIVE;
            stream._destroy(afterDestroy.bind(this));
          }
          return;
        }
        if ((stream._duplexState & IS_OPENING) === OPENING) {
          stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
          stream._open(afterOpen.bind(this));
        }
      }
      continueUpdate() {
        if ((this.stream._duplexState & WRITE_NEXT_TICK) === 0) return false;
        this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
        return true;
      }
      updateCallback() {
        if ((this.stream._duplexState & WRITE_UPDATE_SYNC_STATUS) === WRITE_PRIMARY) this.update();
        else this.updateNextTick();
      }
      updateNextTick() {
        if ((this.stream._duplexState & WRITE_NEXT_TICK) !== 0) return;
        this.stream._duplexState |= WRITE_NEXT_TICK;
        if ((this.stream._duplexState & WRITE_UPDATING) === 0) queueTick(this.afterUpdateNextTick);
      }
    };
    var ReadableState = class {
      constructor(stream, { highWaterMark = 16384, map = null, mapReadable, byteLength, byteLengthReadable } = {}) {
        this.stream = stream;
        this.queue = new FIFO();
        this.highWaterMark = highWaterMark === 0 ? 1 : highWaterMark;
        this.buffered = 0;
        this.readAhead = highWaterMark > 0;
        this.error = null;
        this.pipeline = null;
        this.byteLength = byteLengthReadable || byteLength || defaultByteLength;
        this.map = mapReadable || map;
        this.pipeTo = null;
        this.afterRead = afterRead.bind(this);
        this.afterUpdateNextTick = updateReadNT.bind(this);
      }
      get ended() {
        return (this.stream._duplexState & READ_DONE) !== 0;
      }
      pipe(pipeTo, cb) {
        if (this.pipeTo !== null) throw new Error("Can only pipe to one destination");
        if (typeof cb !== "function") cb = null;
        this.stream._duplexState |= READ_PIPE_DRAINED;
        this.pipeTo = pipeTo;
        this.pipeline = new Pipeline(this.stream, pipeTo, cb);
        if (cb) this.stream.on("error", noop);
        if (isStreamx(pipeTo)) {
          pipeTo._writableState.pipeline = this.pipeline;
          if (cb) pipeTo.on("error", noop);
          pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
        } else {
          const onerror = this.pipeline.done.bind(this.pipeline, pipeTo);
          const onclose = this.pipeline.done.bind(this.pipeline, pipeTo, null);
          pipeTo.on("error", onerror);
          pipeTo.on("close", onclose);
          pipeTo.on("finish", this.pipeline.finished.bind(this.pipeline));
        }
        pipeTo.on("drain", afterDrain.bind(this));
        this.stream.emit("piping", pipeTo);
        pipeTo.emit("pipe", this.stream);
      }
      push(data) {
        const stream = this.stream;
        if (data === null) {
          this.highWaterMark = 0;
          stream._duplexState = (stream._duplexState | READ_ENDING) & READ_NON_PRIMARY_AND_PUSHED;
          return false;
        }
        if (this.map !== null) {
          data = this.map(data);
          if (data === null) {
            stream._duplexState &= READ_PUSHED;
            return this.buffered < this.highWaterMark;
          }
        }
        this.buffered += this.byteLength(data);
        this.queue.push(data);
        stream._duplexState = (stream._duplexState | READ_QUEUED) & READ_PUSHED;
        return this.buffered < this.highWaterMark;
      }
      shift() {
        const data = this.queue.shift();
        this.buffered -= this.byteLength(data);
        if (this.buffered === 0) this.stream._duplexState &= READ_NOT_QUEUED;
        return data;
      }
      unshift(data) {
        const pending = [this.map !== null ? this.map(data) : data];
        while (this.buffered > 0) pending.push(this.shift());
        for (let i = 0; i < pending.length - 1; i++) {
          const data2 = pending[i];
          this.buffered += this.byteLength(data2);
          this.queue.push(data2);
        }
        this.push(pending[pending.length - 1]);
      }
      read() {
        const stream = this.stream;
        if ((stream._duplexState & READ_STATUS) === READ_QUEUED) {
          const data = this.shift();
          if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED;
          if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit("data", data);
          return data;
        }
        if (this.readAhead === false) {
          stream._duplexState |= READ_READ_AHEAD;
          this.updateNextTick();
        }
        return null;
      }
      drain() {
        const stream = this.stream;
        while ((stream._duplexState & READ_STATUS) === READ_QUEUED && (stream._duplexState & READ_FLOWING) !== 0) {
          const data = this.shift();
          if (this.pipeTo !== null && this.pipeTo.write(data) === false) stream._duplexState &= READ_PIPE_NOT_DRAINED;
          if ((stream._duplexState & READ_EMIT_DATA) !== 0) stream.emit("data", data);
        }
      }
      update() {
        const stream = this.stream;
        stream._duplexState |= READ_UPDATING;
        do {
          this.drain();
          while (this.buffered < this.highWaterMark && (stream._duplexState & SHOULD_NOT_READ) === READ_READ_AHEAD) {
            stream._duplexState |= READ_ACTIVE_AND_NEEDS_PUSH;
            stream._read(this.afterRead);
            this.drain();
          }
          if ((stream._duplexState & READ_READABLE_STATUS) === READ_EMIT_READABLE_AND_QUEUED) {
            stream._duplexState |= READ_EMITTED_READABLE;
            stream.emit("readable");
          }
          if ((stream._duplexState & READ_PRIMARY_AND_ACTIVE) === 0) this.updateNonPrimary();
        } while (this.continueUpdate() === true);
        stream._duplexState &= READ_NOT_UPDATING;
      }
      updateNonPrimary() {
        const stream = this.stream;
        if ((stream._duplexState & READ_ENDING_STATUS) === READ_ENDING) {
          stream._duplexState = (stream._duplexState | READ_DONE) & READ_NOT_ENDING;
          stream.emit("end");
          if ((stream._duplexState & AUTO_DESTROY) === DONE) stream._duplexState |= DESTROYING;
          if (this.pipeTo !== null) this.pipeTo.end();
        }
        if ((stream._duplexState & DESTROY_STATUS) === DESTROYING) {
          if ((stream._duplexState & ACTIVE_OR_TICKING) === 0) {
            stream._duplexState |= ACTIVE;
            stream._destroy(afterDestroy.bind(this));
          }
          return;
        }
        if ((stream._duplexState & IS_OPENING) === OPENING) {
          stream._duplexState = (stream._duplexState | ACTIVE) & NOT_OPENING;
          stream._open(afterOpen.bind(this));
        }
      }
      continueUpdate() {
        if ((this.stream._duplexState & READ_NEXT_TICK) === 0) return false;
        this.stream._duplexState &= READ_NOT_NEXT_TICK;
        return true;
      }
      updateCallback() {
        if ((this.stream._duplexState & READ_UPDATE_SYNC_STATUS) === READ_PRIMARY) this.update();
        else this.updateNextTick();
      }
      updateNextTick() {
        if ((this.stream._duplexState & READ_NEXT_TICK) !== 0) return;
        this.stream._duplexState |= READ_NEXT_TICK;
        if ((this.stream._duplexState & READ_UPDATING) === 0) queueTick(this.afterUpdateNextTick);
      }
    };
    var TransformState = class {
      constructor(stream) {
        this.data = null;
        this.afterTransform = afterTransform.bind(stream);
        this.afterFinal = null;
      }
    };
    var Pipeline = class {
      constructor(src, dst, cb) {
        this.from = src;
        this.to = dst;
        this.afterPipe = cb;
        this.error = null;
        this.pipeToFinished = false;
      }
      finished() {
        this.pipeToFinished = true;
      }
      done(stream, err) {
        if (err) this.error = err;
        if (stream === this.to) {
          this.to = null;
          if (this.from !== null) {
            if ((this.from._duplexState & READ_DONE) === 0 || !this.pipeToFinished) {
              this.from.destroy(this.error || new Error("Writable stream closed prematurely"));
            }
            return;
          }
        }
        if (stream === this.from) {
          this.from = null;
          if (this.to !== null) {
            if ((stream._duplexState & READ_DONE) === 0) {
              this.to.destroy(this.error || new Error("Readable stream closed before ending"));
            }
            return;
          }
        }
        if (this.afterPipe !== null) this.afterPipe(this.error);
        this.to = this.from = this.afterPipe = null;
      }
    };
    function afterDrain() {
      this.stream._duplexState |= READ_PIPE_DRAINED;
      this.updateCallback();
    }
    function afterFinal(err) {
      const stream = this.stream;
      if (err) stream.destroy(err);
      if ((stream._duplexState & DESTROY_STATUS) === 0) {
        stream._duplexState |= WRITE_DONE;
        stream.emit("finish");
      }
      if ((stream._duplexState & AUTO_DESTROY) === DONE) {
        stream._duplexState |= DESTROYING;
      }
      stream._duplexState &= WRITE_NOT_ACTIVE;
      if ((stream._duplexState & WRITE_UPDATING) === 0) this.update();
      else this.updateNextTick();
    }
    function afterDestroy(err) {
      const stream = this.stream;
      if (!err && this.error !== STREAM_DESTROYED) err = this.error;
      if (err) stream.emit("error", err);
      stream._duplexState |= DESTROYED;
      stream.emit("close");
      const rs = stream._readableState;
      const ws = stream._writableState;
      if (rs !== null && rs.pipeline !== null) rs.pipeline.done(stream, err);
      if (ws !== null) {
        while (ws.drains !== null && ws.drains.length > 0) ws.drains.shift().resolve(false);
        if (ws.pipeline !== null) ws.pipeline.done(stream, err);
      }
    }
    function afterWrite(err) {
      const stream = this.stream;
      if (err) stream.destroy(err);
      stream._duplexState &= WRITE_NOT_ACTIVE;
      if (this.drains !== null) tickDrains(this.drains);
      if ((stream._duplexState & WRITE_DRAIN_STATUS) === WRITE_UNDRAINED) {
        stream._duplexState &= WRITE_DRAINED;
        if ((stream._duplexState & WRITE_EMIT_DRAIN) === WRITE_EMIT_DRAIN) {
          stream.emit("drain");
        }
      }
      this.updateCallback();
    }
    function afterRead(err) {
      if (err) this.stream.destroy(err);
      this.stream._duplexState &= READ_NOT_ACTIVE;
      if (this.readAhead === false && (this.stream._duplexState & READ_RESUMED) === 0) this.stream._duplexState &= READ_NO_READ_AHEAD;
      this.updateCallback();
    }
    function updateReadNT() {
      if ((this.stream._duplexState & READ_UPDATING) === 0) {
        this.stream._duplexState &= READ_NOT_NEXT_TICK;
        this.update();
      }
    }
    function updateWriteNT() {
      if ((this.stream._duplexState & WRITE_UPDATING) === 0) {
        this.stream._duplexState &= WRITE_NOT_NEXT_TICK;
        this.update();
      }
    }
    function tickDrains(drains) {
      for (let i = 0; i < drains.length; i++) {
        if (--drains[i].writes === 0) {
          drains.shift().resolve(true);
          i--;
        }
      }
    }
    function afterOpen(err) {
      const stream = this.stream;
      if (err) stream.destroy(err);
      if ((stream._duplexState & DESTROYING) === 0) {
        if ((stream._duplexState & READ_PRIMARY_STATUS) === 0) stream._duplexState |= READ_PRIMARY;
        if ((stream._duplexState & WRITE_PRIMARY_STATUS) === 0) stream._duplexState |= WRITE_PRIMARY;
        stream.emit("open");
      }
      stream._duplexState &= NOT_ACTIVE;
      if (stream._writableState !== null) {
        stream._writableState.updateCallback();
      }
      if (stream._readableState !== null) {
        stream._readableState.updateCallback();
      }
    }
    function afterTransform(err, data) {
      if (data !== void 0 && data !== null) this.push(data);
      this._writableState.afterWrite(err);
    }
    function newListener(name) {
      if (this._readableState !== null) {
        if (name === "data") {
          this._duplexState |= READ_EMIT_DATA | READ_RESUMED_READ_AHEAD;
          this._readableState.updateNextTick();
        }
        if (name === "readable") {
          this._duplexState |= READ_EMIT_READABLE;
          this._readableState.updateNextTick();
        }
      }
      if (this._writableState !== null) {
        if (name === "drain") {
          this._duplexState |= WRITE_EMIT_DRAIN;
          this._writableState.updateNextTick();
        }
      }
    }
    var Stream = class extends EventEmitter2 {
      constructor(opts) {
        super();
        this._duplexState = 0;
        this._readableState = null;
        this._writableState = null;
        if (opts) {
          if (opts.open) this._open = opts.open;
          if (opts.destroy) this._destroy = opts.destroy;
          if (opts.predestroy) this._predestroy = opts.predestroy;
          if (opts.signal) {
            opts.signal.addEventListener("abort", abort.bind(this));
          }
        }
        this.on("newListener", newListener);
      }
      _open(cb) {
        cb(null);
      }
      _destroy(cb) {
        cb(null);
      }
      _predestroy() {
      }
      get readable() {
        return this._readableState !== null ? true : void 0;
      }
      get writable() {
        return this._writableState !== null ? true : void 0;
      }
      get destroyed() {
        return (this._duplexState & DESTROYED) !== 0;
      }
      get destroying() {
        return (this._duplexState & DESTROY_STATUS) !== 0;
      }
      destroy(err) {
        if ((this._duplexState & DESTROY_STATUS) === 0) {
          if (!err) err = STREAM_DESTROYED;
          this._duplexState = (this._duplexState | DESTROYING) & NON_PRIMARY;
          if (this._readableState !== null) {
            this._readableState.highWaterMark = 0;
            this._readableState.error = err;
          }
          if (this._writableState !== null) {
            this._writableState.highWaterMark = 0;
            this._writableState.error = err;
          }
          this._duplexState |= PREDESTROYING;
          this._predestroy();
          this._duplexState &= NOT_PREDESTROYING;
          if (this._readableState !== null) this._readableState.updateNextTick();
          if (this._writableState !== null) this._writableState.updateNextTick();
        }
      }
    };
    var Readable = class _Readable extends Stream {
      constructor(opts) {
        super(opts);
        this._duplexState |= OPENING | WRITE_DONE | READ_READ_AHEAD;
        this._readableState = new ReadableState(this, opts);
        if (opts) {
          if (this._readableState.readAhead === false) this._duplexState &= READ_NO_READ_AHEAD;
          if (opts.read) this._read = opts.read;
          if (opts.eagerOpen) this._readableState.updateNextTick();
          if (opts.encoding) this.setEncoding(opts.encoding);
        }
      }
      setEncoding(encoding) {
        const dec = new TextDecoder2(encoding);
        const map = this._readableState.map || echo;
        this._readableState.map = mapOrSkip;
        return this;
        function mapOrSkip(data) {
          const next = dec.push(data);
          return next === "" && (data.byteLength !== 0 || dec.remaining > 0) ? null : map(next);
        }
      }
      _read(cb) {
        cb(null);
      }
      pipe(dest, cb) {
        this._readableState.updateNextTick();
        this._readableState.pipe(dest, cb);
        return dest;
      }
      read() {
        this._readableState.updateNextTick();
        return this._readableState.read();
      }
      push(data) {
        this._readableState.updateNextTick();
        return this._readableState.push(data);
      }
      unshift(data) {
        this._readableState.updateNextTick();
        return this._readableState.unshift(data);
      }
      resume() {
        this._duplexState |= READ_RESUMED_READ_AHEAD;
        this._readableState.updateNextTick();
        return this;
      }
      pause() {
        this._duplexState &= this._readableState.readAhead === false ? READ_PAUSED_NO_READ_AHEAD : READ_PAUSED;
        return this;
      }
      static _fromAsyncIterator(ite, opts) {
        let destroy;
        const rs = new _Readable({
          ...opts,
          read(cb) {
            ite.next().then(push).then(cb.bind(null, null)).catch(cb);
          },
          predestroy() {
            destroy = ite.return();
          },
          destroy(cb) {
            if (!destroy) return cb(null);
            destroy.then(cb.bind(null, null)).catch(cb);
          }
        });
        return rs;
        function push(data) {
          if (data.done) rs.push(null);
          else rs.push(data.value);
        }
      }
      static from(data, opts) {
        if (isReadStreamx(data)) return data;
        if (data[asyncIterator]) return this._fromAsyncIterator(data[asyncIterator](), opts);
        if (!Array.isArray(data)) data = data === void 0 ? [] : [data];
        let i = 0;
        return new _Readable({
          ...opts,
          read(cb) {
            this.push(i === data.length ? null : data[i++]);
            cb(null);
          }
        });
      }
      static isBackpressured(rs) {
        return (rs._duplexState & READ_BACKPRESSURE_STATUS) !== 0 || rs._readableState.buffered >= rs._readableState.highWaterMark;
      }
      static isPaused(rs) {
        return (rs._duplexState & READ_RESUMED) === 0;
      }
      [asyncIterator]() {
        const stream = this;
        let error = null;
        let promiseResolve = null;
        let promiseReject = null;
        this.on("error", (err) => {
          error = err;
        });
        this.on("readable", onreadable);
        this.on("close", onclose);
        return {
          [asyncIterator]() {
            return this;
          },
          next() {
            return new Promise(function(resolve, reject) {
              promiseResolve = resolve;
              promiseReject = reject;
              const data = stream.read();
              if (data !== null) ondata(data);
              else if ((stream._duplexState & DESTROYED) !== 0) ondata(null);
            });
          },
          return() {
            return destroy(null);
          },
          throw(err) {
            return destroy(err);
          }
        };
        function onreadable() {
          if (promiseResolve !== null) ondata(stream.read());
        }
        function onclose() {
          if (promiseResolve !== null) ondata(null);
        }
        function ondata(data) {
          if (promiseReject === null) return;
          if (error) promiseReject(error);
          else if (data === null && (stream._duplexState & READ_DONE) === 0) promiseReject(STREAM_DESTROYED);
          else promiseResolve({ value: data, done: data === null });
          promiseReject = promiseResolve = null;
        }
        function destroy(err) {
          stream.destroy(err);
          return new Promise((resolve, reject) => {
            if (stream._duplexState & DESTROYED) return resolve({ value: void 0, done: true });
            stream.once("close", function() {
              if (err) reject(err);
              else resolve({ value: void 0, done: true });
            });
          });
        }
      }
    };
    var Writable = class extends Stream {
      constructor(opts) {
        super(opts);
        this._duplexState |= OPENING | READ_DONE;
        this._writableState = new WritableState(this, opts);
        if (opts) {
          if (opts.writev) this._writev = opts.writev;
          if (opts.write) this._write = opts.write;
          if (opts.final) this._final = opts.final;
          if (opts.eagerOpen) this._writableState.updateNextTick();
        }
      }
      cork() {
        this._duplexState |= WRITE_CORKED;
      }
      uncork() {
        this._duplexState &= WRITE_NOT_CORKED;
        this._writableState.updateNextTick();
      }
      _writev(batch, cb) {
        cb(null);
      }
      _write(data, cb) {
        this._writableState.autoBatch(data, cb);
      }
      _final(cb) {
        cb(null);
      }
      static isBackpressured(ws) {
        return (ws._duplexState & WRITE_BACKPRESSURE_STATUS) !== 0;
      }
      static drained(ws) {
        if (ws.destroyed) return Promise.resolve(false);
        const state = ws._writableState;
        const pending = isWritev(ws) ? Math.min(1, state.queue.length) : state.queue.length;
        const writes = pending + (ws._duplexState & WRITE_WRITING ? 1 : 0);
        if (writes === 0) return Promise.resolve(true);
        if (state.drains === null) state.drains = [];
        return new Promise((resolve) => {
          state.drains.push({ writes, resolve });
        });
      }
      write(data) {
        this._writableState.updateNextTick();
        return this._writableState.push(data);
      }
      end(data) {
        this._writableState.updateNextTick();
        this._writableState.end(data);
        return this;
      }
    };
    var Duplex2 = class extends Readable {
      // and Writable
      constructor(opts) {
        super(opts);
        this._duplexState = OPENING | this._duplexState & READ_READ_AHEAD;
        this._writableState = new WritableState(this, opts);
        if (opts) {
          if (opts.writev) this._writev = opts.writev;
          if (opts.write) this._write = opts.write;
          if (opts.final) this._final = opts.final;
        }
      }
      cork() {
        this._duplexState |= WRITE_CORKED;
      }
      uncork() {
        this._duplexState &= WRITE_NOT_CORKED;
        this._writableState.updateNextTick();
      }
      _writev(batch, cb) {
        cb(null);
      }
      _write(data, cb) {
        this._writableState.autoBatch(data, cb);
      }
      _final(cb) {
        cb(null);
      }
      write(data) {
        this._writableState.updateNextTick();
        return this._writableState.push(data);
      }
      end(data) {
        this._writableState.updateNextTick();
        this._writableState.end(data);
        return this;
      }
    };
    var Transform2 = class extends Duplex2 {
      constructor(opts) {
        super(opts);
        this._transformState = new TransformState(this);
        if (opts) {
          if (opts.transform) this._transform = opts.transform;
          if (opts.flush) this._flush = opts.flush;
        }
      }
      _write(data, cb) {
        if (this._readableState.buffered >= this._readableState.highWaterMark) {
          this._transformState.data = data;
        } else {
          this._transform(data, this._transformState.afterTransform);
        }
      }
      _read(cb) {
        if (this._transformState.data !== null) {
          const data = this._transformState.data;
          this._transformState.data = null;
          cb(null);
          this._transform(data, this._transformState.afterTransform);
        } else {
          cb(null);
        }
      }
      destroy(err) {
        super.destroy(err);
        if (this._transformState.data !== null) {
          this._transformState.data = null;
          this._transformState.afterTransform();
        }
      }
      _transform(data, cb) {
        cb(null, data);
      }
      _flush(cb) {
        cb(null);
      }
      _final(cb) {
        this._transformState.afterFinal = cb;
        this._flush(transformAfterFlush.bind(this));
      }
    };
    var PassThrough = class extends Transform2 {
    };
    function transformAfterFlush(err, data) {
      const cb = this._transformState.afterFinal;
      if (err) return cb(err);
      if (data !== null && data !== void 0) this.push(data);
      this.push(null);
      cb(null);
    }
    function pipelinePromise(...streams) {
      return new Promise((resolve, reject) => {
        return pipeline2(...streams, (err) => {
          if (err) return reject(err);
          resolve();
        });
      });
    }
    function pipeline2(stream, ...streams) {
      const all = Array.isArray(stream) ? [...stream, ...streams] : [stream, ...streams];
      const done = all.length && typeof all[all.length - 1] === "function" ? all.pop() : null;
      if (all.length < 2) throw new Error("Pipeline requires at least 2 streams");
      let src = all[0];
      let dest = null;
      let error = null;
      for (let i = 1; i < all.length; i++) {
        dest = all[i];
        if (isStreamx(src)) {
          src.pipe(dest, onerror);
        } else {
          errorHandle(src, true, i > 1, onerror);
          src.pipe(dest);
        }
        src = dest;
      }
      if (done) {
        let fin = false;
        const autoDestroy = isStreamx(dest) || !!(dest._writableState && dest._writableState.autoDestroy);
        dest.on("error", (err) => {
          if (error === null) error = err;
        });
        dest.on("finish", () => {
          fin = true;
          if (!autoDestroy) done(error);
        });
        if (autoDestroy) {
          dest.on("close", () => done(error || (fin ? null : PREMATURE_CLOSE)));
        }
      }
      return dest;
      function errorHandle(s, rd, wr, onerror2) {
        s.on("error", onerror2);
        s.on("close", onclose);
        function onclose() {
          if (rd && s._readableState && !s._readableState.ended) return onerror2(PREMATURE_CLOSE);
          if (wr && s._writableState && !s._writableState.ended) return onerror2(PREMATURE_CLOSE);
        }
      }
      function onerror(err) {
        if (!err || error) return;
        error = err;
        for (const s of all) {
          s.destroy(err);
        }
      }
    }
    function echo(s) {
      return s;
    }
    function isStream(stream) {
      return !!stream._readableState || !!stream._writableState;
    }
    function isStreamx(stream) {
      return typeof stream._duplexState === "number" && isStream(stream);
    }
    function isEnded(stream) {
      return !!stream._readableState && stream._readableState.ended;
    }
    function isFinished(stream) {
      return !!stream._writableState && stream._writableState.ended;
    }
    function getStreamError(stream, opts = {}) {
      const err = stream._readableState && stream._readableState.error || stream._writableState && stream._writableState.error;
      return !opts.all && err === STREAM_DESTROYED ? null : err;
    }
    function isReadStreamx(stream) {
      return isStreamx(stream) && stream.readable;
    }
    function isTypedArray(data) {
      return typeof data === "object" && data !== null && typeof data.byteLength === "number";
    }
    function defaultByteLength(data) {
      return isTypedArray(data) ? data.byteLength : 1024;
    }
    function noop() {
    }
    function abort() {
      this.destroy(new Error("Stream aborted."));
    }
    function isWritev(s) {
      return s._writev !== Writable.prototype._writev && s._writev !== Duplex2.prototype._writev;
    }
    module.exports = {
      pipeline: pipeline2,
      pipelinePromise,
      isStream,
      isStreamx,
      isEnded,
      isFinished,
      getStreamError,
      Stream,
      Writable,
      Readable,
      Duplex: Duplex2,
      Transform: Transform2,
      // Export PassThrough for compatibility with Node.js core's stream module
      PassThrough
    };
  }
});

// node_modules/unordered-array-remove/index.js
var require_unordered_array_remove = __commonJS({
  "node_modules/unordered-array-remove/index.js"(exports, module) {
    module.exports = remove;
    function remove(arr, i) {
      if (i >= arr.length || i < 0) return;
      var last = arr.pop();
      if (i < arr.length) {
        var tmp = arr[i];
        arr[i] = last;
        return tmp;
      }
      return last;
    }
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash2 = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug3(...args) {
          if (!debug3.enabled) {
            return;
          }
          const self2 = debug3;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug3.namespace = namespace;
        debug3.useColors = createDebug.useColors();
        debug3.color = createDebug.selectColor(namespace);
        debug3.extend = extend;
        debug3.destroy = createDebug.destroy;
        Object.defineProperty(debug3, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug3);
        }
        return debug3;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/rc4/rc4.js
var require_rc4 = __commonJS({
  "node_modules/rc4/rc4.js"(exports, module) {
    "use strict";
    function isInteger(n) {
      return parseInt(n, 10) === n;
    }
    function createRC4(N) {
      function identityPermutation() {
        var s = new Array(N);
        for (var i = 0; i < N; i++) {
          s[i] = i;
        }
        return s;
      }
      function seed(key) {
        if (key === void 0) {
          key = new Array(N);
          for (var k = 0; k < N; k++) {
            key[k] = Math.floor(Math.random() * N);
          }
        } else if (typeof key === "string") {
          key = "" + key;
          key = key.split("").map(function(c) {
            return c.charCodeAt(0) % N;
          });
        } else if (Array.isArray(key)) {
          if (!key.every(function(v) {
            return typeof v === "number" && v === (v | 0);
          })) {
            throw new TypeError("invalid seed key specified: not array of integers");
          }
        } else {
          throw new TypeError("invalid seed key specified");
        }
        var keylen = key.length;
        var s = identityPermutation();
        var j = 0;
        for (var i = 0; i < N; i++) {
          j = (j + s[i] + key[i % keylen]) % N;
          var tmp = s[i];
          s[i] = s[j];
          s[j] = tmp;
        }
        return s;
      }
      function RC43(key) {
        this.s = seed(key);
        this.i = 0;
        this.j = 0;
      }
      RC43.prototype.randomNative = function() {
        this.i = (this.i + 1) % N;
        this.j = (this.j + this.s[this.i]) % N;
        var tmp = this.s[this.i];
        this.s[this.i] = this.s[this.j];
        this.s[this.j] = tmp;
        var k = this.s[(this.s[this.i] + this.s[this.j]) % N];
        return k;
      };
      RC43.prototype.randomUInt32 = function() {
        var a = this.randomByte();
        var b = this.randomByte();
        var c = this.randomByte();
        var d = this.randomByte();
        return ((a * 256 + b) * 256 + c) * 256 + d;
      };
      RC43.prototype.randomFloat = function() {
        return this.randomUInt32() / 4294967296;
      };
      RC43.prototype.random = function() {
        var a;
        var b;
        if (arguments.length === 1) {
          a = 0;
          b = arguments[0];
        } else if (arguments.length === 2) {
          a = arguments[0];
          b = arguments[1];
        } else {
          throw new TypeError("random takes one or two integer arguments");
        }
        if (!isInteger(a) || !isInteger(b)) {
          throw new TypeError("random takes one or two integer arguments");
        }
        return a + this.randomUInt32() % (b - a + 1);
      };
      RC43.prototype.currentState = function() {
        return {
          i: this.i,
          j: this.j,
          s: this.s.slice()
          // copy
        };
      };
      RC43.prototype.setState = function(state) {
        var s = state.s;
        var i = state.i;
        var j = state.j;
        if (!(i === (i | 0) && 0 <= i && i < N)) {
          throw new Error("state.i should be integer [0, " + (N - 1) + "]");
        }
        if (!(j === (j | 0) && 0 <= j && j < N)) {
          throw new Error("state.j should be integer [0, " + (N - 1) + "]");
        }
        if (!Array.isArray(s) || s.length !== N) {
          throw new Error("state should be array of length " + N);
        }
        for (var k = 0; k < N; k++) {
          if (s.indexOf(k) === -1) {
            throw new Error("state should be permutation of 0.." + (N - 1) + ": " + k + " is missing");
          }
        }
        this.i = i;
        this.j = j;
        this.s = s.slice();
      };
      return RC43;
    }
    var RC42 = createRC4(256);
    RC42.prototype.randomByte = RC42.prototype.randomNative;
    var RC4small = createRC4(16);
    RC4small.prototype.randomByte = function() {
      var a = this.randomNative();
      var b = this.randomNative();
      return a * 16 + b;
    };
    var ordA = "a".charCodeAt(0);
    var ord0 = "0".charCodeAt(0);
    function toHex(n) {
      return n < 10 ? String.fromCharCode(ord0 + n) : String.fromCharCode(ordA + n - 10);
    }
    function fromHex(c) {
      return parseInt(c, 16);
    }
    RC4small.prototype.currentStateString = function() {
      var state = this.currentState();
      var i = toHex(state.i);
      var j = toHex(state.j);
      var res = i + j + state.s.map(toHex).join("");
      return res;
    };
    RC4small.prototype.setStateString = function(stateString) {
      if (!stateString.match(/^[0-9a-f]{18}$/)) {
        throw new TypeError("RC4small stateString should be 18 hex character string");
      }
      var i = fromHex(stateString[0]);
      var j = fromHex(stateString[1]);
      var s = stateString.split("").slice(2).map(fromHex);
      this.setState({
        i,
        j,
        s
      });
    };
    RC42.RC4small = RC4small;
    module.exports = RC42;
  }
});

// node_modules/throughput/index.js
var require_throughput = __commonJS({
  "node_modules/throughput/index.js"(exports, module) {
    var maxTick = 65535;
    var resolution = 10;
    var timeDiff = 1e3 / resolution;
    function getTick(start) {
      return (+Date.now() - start) / timeDiff & 65535;
    }
    module.exports = function(seconds) {
      const start = +Date.now();
      const size = resolution * (seconds || 5);
      const buffer = [0];
      let pointer = 1;
      let last = getTick(start) - 1 & maxTick;
      return function(delta) {
        const tick = getTick(start);
        let dist = tick - last & maxTick;
        if (dist > size) dist = size;
        last = tick;
        while (dist--) {
          if (pointer === size) pointer = 0;
          buffer[pointer] = buffer[pointer === 0 ? size - 1 : pointer - 1];
          pointer++;
        }
        if (delta) buffer[pointer - 1] += delta;
        const top = buffer[pointer - 1];
        const btm = buffer.length < size ? 0 : buffer[pointer === size ? 0 : pointer];
        return buffer.length < resolution ? top : (top - btm) * resolution / buffer.length;
      };
    };
  }
});

// node_modules/webtorrent/lib/peer.js
var import_events = __toESM(require_events(), 1);
var import_streamx2 = __toESM(require_streamx(), 1);
var import_unordered_array_remove2 = __toESM(require_unordered_array_remove(), 1);
var import_debug2 = __toESM(require_browser(), 1);

// node_modules/uint8-util/util.js
var alphabet = "0123456789abcdef";
var encodeLookup = [];
var decodeLookup = [];
for (let i = 0; i < 256; i++) {
  encodeLookup[i] = alphabet[i >> 4 & 15] + alphabet[i & 15];
  if (i < 16) {
    if (i < 10) {
      decodeLookup[48 + i] = i;
    } else {
      decodeLookup[97 - 10 + i] = i;
    }
  }
}
var arr2hex = (data) => {
  const length = data.length;
  let string = "";
  let i = 0;
  while (i < length) {
    string += encodeLookup[data[i++]];
  }
  return string;
};
var hex2arr = (str) => {
  const sizeof = str.length >> 1;
  const length = sizeof << 1;
  const array = new Uint8Array(sizeof);
  let n = 0;
  let i = 0;
  while (i < length) {
    array[n++] = decodeLookup[str.charCodeAt(i++)] << 4 | decodeLookup[str.charCodeAt(i++)];
  }
  return array;
};
var concat = (chunks, size = 0) => {
  const length = chunks.length || 0;
  if (!size) {
    let i2 = length;
    while (i2--) size += chunks[i2].length;
  }
  const b = new Uint8Array(size);
  let offset = size;
  let i = length;
  while (i--) {
    offset -= chunks[i].length;
    b.set(chunks[i], offset);
  }
  return b;
};
var equal = (a, b) => {
  if (a.length !== b.length) return false;
  for (let i = a.length; i > -1; i -= 1) {
    if (a[i] !== b[i]) return false;
  }
  return true;
};

// node_modules/base64-arraybuffer/dist/base64-arraybuffer.es5.js
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (i = 0; i < chars.length; i++) {
  lookup[chars.charCodeAt(i)] = i;
}
var i;
var encode = function(arraybuffer) {
  var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = "";
  for (i = 0; i < len; i += 3) {
    base64 += chars[bytes[i] >> 2];
    base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
    base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
    base64 += chars[bytes[i + 2] & 63];
  }
  if (len % 3 === 2) {
    base64 = base64.substring(0, base64.length - 1) + "=";
  } else if (len % 3 === 1) {
    base64 = base64.substring(0, base64.length - 2) + "==";
  }
  return base64;
};

// node_modules/uint8-util/browser.js
var decoder = new TextDecoder();
var arr2text = (data, enc) => {
  if (!enc) return decoder.decode(data);
  const dec = new TextDecoder(enc);
  return dec.decode(data);
};
var encoder = new TextEncoder();
var text2arr = (str) => encoder.encode(str);
var arr2base = (data) => encode(data);
var bin2hex = (str) => {
  let res = "";
  let c;
  let i = 0;
  const len = str.length;
  while (i < len) {
    c = str.charCodeAt(i++);
    res += alphabet[c >> 4] + alphabet[c & 15];
  }
  return res;
};
var MAX_ARGUMENTS_LENGTH = 65536;
var hex2bin = (hex) => {
  const points = hex2arr(hex);
  if (points.length <= MAX_ARGUMENTS_LENGTH) return String.fromCharCode(...points);
  let res = "";
  let i = 0;
  while (i < points.length) {
    res += String.fromCharCode(...points.subarray(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
};
var scope = typeof window !== "undefined" ? window : self;
var crypto = scope.crypto || scope.msCrypto || {};
var subtle = crypto.subtle || crypto.webkitSubtle;
var formatMap = {
  hex: arr2hex,
  base64: arr2base
};
var hash = async (data, format, algo = "sha-1") => {
  if (!subtle) throw new Error("no web crypto support");
  if (typeof data === "string") data = text2arr(data);
  const out = new Uint8Array(await subtle.digest(algo, data));
  return format ? formatMap[format](out) : out;
};
var randomBytes = (size) => {
  const view = new Uint8Array(size);
  return crypto.getRandomValues(view);
};

// node_modules/bencode/lib/util.js
function digitCount(value) {
  const sign = value < 0 ? 1 : 0;
  value = Math.abs(Number(value || 1));
  return Math.floor(Math.log10(value)) + 1 + sign;
}
function getType(value) {
  if (ArrayBuffer.isView(value)) return "arraybufferview";
  if (Array.isArray(value)) return "array";
  if (value instanceof Number) return "number";
  if (value instanceof Boolean) return "boolean";
  if (value instanceof Set) return "set";
  if (value instanceof Map) return "map";
  if (value instanceof String) return "string";
  if (value instanceof ArrayBuffer) return "arraybuffer";
  return typeof value;
}

// node_modules/bencode/lib/encode.js
function encode2(data, buffer, offset) {
  const buffers = [];
  let result = null;
  encode2._encode(buffers, data);
  result = concat(buffers);
  encode2.bytes = result.length;
  if (ArrayBuffer.isView(buffer)) {
    buffer.set(result, offset);
    return buffer;
  }
  return result;
}
encode2.bytes = -1;
encode2._floatConversionDetected = false;
encode2._encode = function(buffers, data) {
  if (data == null) {
    return;
  }
  switch (getType(data)) {
    case "object":
      encode2.dict(buffers, data);
      break;
    case "map":
      encode2.dictMap(buffers, data);
      break;
    case "array":
      encode2.list(buffers, data);
      break;
    case "set":
      encode2.listSet(buffers, data);
      break;
    case "string":
      encode2.string(buffers, data);
      break;
    case "number":
      encode2.number(buffers, data);
      break;
    case "boolean":
      encode2.number(buffers, data);
      break;
    case "arraybufferview":
      encode2.buffer(buffers, new Uint8Array(data.buffer, data.byteOffset, data.byteLength));
      break;
    case "arraybuffer":
      encode2.buffer(buffers, new Uint8Array(data));
      break;
  }
};
var buffE = new Uint8Array([101]);
var buffD = new Uint8Array([100]);
var buffL = new Uint8Array([108]);
encode2.buffer = function(buffers, data) {
  buffers.push(text2arr(data.length + ":"), data);
};
encode2.string = function(buffers, data) {
  buffers.push(text2arr(text2arr(data).byteLength + ":" + data));
};
encode2.number = function(buffers, data) {
  if (Number.isInteger(data)) return buffers.push(text2arr("i" + BigInt(data) + "e"));
  const maxLo = 2147483648;
  const hi = data / maxLo << 0;
  const lo = data % maxLo << 0;
  const val = hi * maxLo + lo;
  buffers.push(text2arr("i" + val + "e"));
  if (val !== data && !encode2._floatConversionDetected) {
    encode2._floatConversionDetected = true;
    console.warn(
      'WARNING: Possible data corruption detected with value "' + data + '":',
      'Bencoding only defines support for integers, value was converted to "' + val + '"'
    );
    console.trace();
  }
};
encode2.dict = function(buffers, data) {
  buffers.push(buffD);
  let j = 0;
  let k;
  const keys = Object.keys(data).sort();
  const kl = keys.length;
  for (; j < kl; j++) {
    k = keys[j];
    if (data[k] == null) continue;
    encode2.string(buffers, k);
    encode2._encode(buffers, data[k]);
  }
  buffers.push(buffE);
};
encode2.dictMap = function(buffers, data) {
  buffers.push(buffD);
  const keys = Array.from(data.keys()).sort();
  for (const key of keys) {
    if (data.get(key) == null) continue;
    ArrayBuffer.isView(key) ? encode2._encode(buffers, key) : encode2.string(buffers, String(key));
    encode2._encode(buffers, data.get(key));
  }
  buffers.push(buffE);
};
encode2.list = function(buffers, data) {
  let i = 0;
  const c = data.length;
  buffers.push(buffL);
  for (; i < c; i++) {
    if (data[i] == null) continue;
    encode2._encode(buffers, data[i]);
  }
  buffers.push(buffE);
};
encode2.listSet = function(buffers, data) {
  buffers.push(buffL);
  for (const item of data) {
    if (item == null) continue;
    encode2._encode(buffers, item);
  }
  buffers.push(buffE);
};
var encode_default = encode2;

// node_modules/bencode/lib/decode.js
var INTEGER_START = 105;
var STRING_DELIM = 58;
var DICTIONARY_START = 100;
var LIST_START = 108;
var END_OF_TYPE = 101;
function getIntFromBuffer(buffer, start, end) {
  let sum = 0;
  let sign = 1;
  for (let i = start; i < end; i++) {
    const num = buffer[i];
    if (num < 58 && num >= 48) {
      sum = sum * 10 + (num - 48);
      continue;
    }
    if (i === start && num === 43) {
      continue;
    }
    if (i === start && num === 45) {
      sign = -1;
      continue;
    }
    if (num === 46) {
      break;
    }
    throw new Error("not a number: buffer[" + i + "] = " + num);
  }
  return sum * sign;
}
function decode2(data, start, end, encoding) {
  if (data == null || data.length === 0) {
    return null;
  }
  if (typeof start !== "number" && encoding == null) {
    encoding = start;
    start = void 0;
  }
  if (typeof end !== "number" && encoding == null) {
    encoding = end;
    end = void 0;
  }
  decode2.position = 0;
  decode2.encoding = encoding || null;
  decode2.data = !ArrayBuffer.isView(data) ? text2arr(data) : new Uint8Array(data.slice(start, end));
  decode2.bytes = decode2.data.length;
  return decode2.next();
}
decode2.bytes = 0;
decode2.position = 0;
decode2.data = null;
decode2.encoding = null;
decode2.next = function() {
  switch (decode2.data[decode2.position]) {
    case DICTIONARY_START:
      return decode2.dictionary();
    case LIST_START:
      return decode2.list();
    case INTEGER_START:
      return decode2.integer();
    default:
      return decode2.buffer();
  }
};
decode2.find = function(chr) {
  let i = decode2.position;
  const c = decode2.data.length;
  const d = decode2.data;
  while (i < c) {
    if (d[i] === chr) return i;
    i++;
  }
  throw new Error(
    'Invalid data: Missing delimiter "' + String.fromCharCode(chr) + '" [0x' + chr.toString(16) + "]"
  );
};
decode2.dictionary = function() {
  decode2.position++;
  const dict = {};
  while (decode2.data[decode2.position] !== END_OF_TYPE) {
    const buffer = decode2.buffer();
    let key = arr2text(buffer);
    if (key.includes("�")) key = arr2hex(buffer);
    dict[key] = decode2.next();
  }
  decode2.position++;
  return dict;
};
decode2.list = function() {
  decode2.position++;
  const lst = [];
  while (decode2.data[decode2.position] !== END_OF_TYPE) {
    lst.push(decode2.next());
  }
  decode2.position++;
  return lst;
};
decode2.integer = function() {
  const end = decode2.find(END_OF_TYPE);
  const number = getIntFromBuffer(decode2.data, decode2.position + 1, end);
  decode2.position += end + 1 - decode2.position;
  return number;
};
decode2.buffer = function() {
  let sep = decode2.find(STRING_DELIM);
  const length = getIntFromBuffer(decode2.data, decode2.position, sep);
  const end = ++sep + length;
  decode2.position = end;
  return decode2.encoding ? arr2text(decode2.data.slice(sep, end)) : decode2.data.slice(sep, end);
};
var decode_default = decode2;

// node_modules/bencode/lib/encoding-length.js
function listLength(list) {
  let length = 1 + 1;
  for (const value of list) {
    length += encodingLength(value);
  }
  return length;
}
function mapLength(map) {
  let length = 1 + 1;
  for (const [key, value] of map) {
    const keyLength = text2arr(key).byteLength;
    length += digitCount(keyLength) + 1 + keyLength;
    length += encodingLength(value);
  }
  return length;
}
function objectLength(value) {
  let length = 1 + 1;
  const keys = Object.keys(value);
  for (let i = 0; i < keys.length; i++) {
    const keyLength = text2arr(keys[i]).byteLength;
    length += digitCount(keyLength) + 1 + keyLength;
    length += encodingLength(value[keys[i]]);
  }
  return length;
}
function stringLength(value) {
  const length = text2arr(value).byteLength;
  return digitCount(length) + 1 + length;
}
function arrayBufferLength(value) {
  const length = value.byteLength - value.byteOffset;
  return digitCount(length) + 1 + length;
}
function encodingLength(value) {
  const length = 0;
  if (value == null) return length;
  const type = getType(value);
  switch (type) {
    case "arraybufferview":
      return arrayBufferLength(value);
    case "string":
      return stringLength(value);
    case "array":
    case "set":
      return listLength(value);
    case "number":
      return 1 + digitCount(Math.floor(value)) + 1;
    case "bigint":
      return 1 + value.toString().length + 1;
    case "object":
      return objectLength(value);
    case "map":
      return mapLength(value);
    default:
      throw new TypeError(`Unsupported value of type "${type}"`);
  }
}
var encoding_length_default = encodingLength;

// node_modules/bencode/index.js
var encodingLength2 = encoding_length_default;
var bencode_default = { encode: encode_default, decode: decode_default, byteLength: encoding_length_default, encodingLength: encodingLength2 };

// node_modules/bitfield/lib/esm/index.js
function bitsToBytes(numberOfBits) {
  return (numberOfBits >> 3) + Number(numberOfBits % 8 !== 0);
}
var BitField = class {
  /** The number of bits in the bitfield. */
  get length() {
    return this.buffer.length << 3;
  }
  /**
   * Constructs a BitField.
   *
   * @param data Either a number representing the maximum number of supported bits, or a Uint8Array.
   * @param opts Options for the bitfield.
   */
  constructor(data = 0, options) {
    const grow = options === null || options === void 0 ? void 0 : options.grow;
    this.grow = grow ? Number.isFinite(grow) ? bitsToBytes(grow) : grow : 0;
    this.buffer = typeof data === "number" ? new Uint8Array(bitsToBytes(data)) : data;
  }
  /**
   * Get a particular bit.
   *
   * @param bitIndex Bit index to retrieve.
   * @returns A boolean indicating whether the `i`th bit is set.
   */
  get(bitIndex) {
    const byteIndex = bitIndex >> 3;
    return byteIndex < this.buffer.length && !!(this.buffer[byteIndex] & 128 >> bitIndex % 8);
  }
  /**
   * Set a particular bit.
   *
   * Will grow the underlying array if the bit is out of bounds and the `grow` option is set.
   *
   * @param bitIndex Bit index to set.
   * @param value Value to set the bit to. Defaults to `true`.
   */
  set(bitIndex, value = true) {
    const byteIndex = bitIndex >> 3;
    if (value) {
      if (byteIndex >= this.buffer.length) {
        const newLength = Math.max(byteIndex + 1, Math.min(2 * this.buffer.length, this.grow));
        if (newLength <= this.grow) {
          const newBuffer = new Uint8Array(newLength);
          newBuffer.set(this.buffer);
          this.buffer = newBuffer;
        }
      }
      this.buffer[byteIndex] |= 128 >> bitIndex % 8;
    } else if (byteIndex < this.buffer.length) {
      this.buffer[byteIndex] &= ~(128 >> bitIndex % 8);
    }
  }
  /**
   * Sets a value or an array of values.
   *
   * @param array An array of booleans to set.
   * @param offset The bit offset at which the values are to be written.
   */
  setAll(array, offset = 0) {
    const targetLength = Math.min(bitsToBytes(offset + array.length), this.grow);
    if (this.buffer.length < targetLength) {
      const newBuffer = new Uint8Array(targetLength);
      newBuffer.set(this.buffer);
      this.buffer = newBuffer;
    }
    let byteIndex = offset >> 3;
    let bitMask = 128 >> offset % 8;
    for (let index = 0; index < array.length; index++) {
      if (array[index]) {
        this.buffer[byteIndex] |= bitMask;
      } else {
        this.buffer[byteIndex] &= ~bitMask;
      }
      if (bitMask === 1) {
        byteIndex += 1;
        if (byteIndex >= this.buffer.length) {
          break;
        }
        bitMask = 128;
      } else {
        bitMask >>= 1;
      }
    }
  }
  /**
   * Loop through the bits in the bitfield.
   *
   * @param callbackfn Function to be called with the bit value and index.
   * @param start Index of the first bit to look at.
   * @param end Index of the first bit that should no longer be considered.
   */
  forEach(callbackfn, start = 0, end = this.buffer.length * 8) {
    let byteIndex = start >> 3;
    let bitMask = 128 >> start % 8;
    for (let bitIndex = start; bitIndex < end; bitIndex++) {
      callbackfn(!!(this.buffer[byteIndex] & bitMask), bitIndex);
      if (bitMask === 1) {
        byteIndex += 1;
        bitMask = 128;
      } else {
        bitMask >>= 1;
      }
    }
  }
  /**
   * Check if all bits in the Bitfield are unset.
   *
   * @returns A boolean indicating whether all bits are unset.
   */
  isEmpty() {
    for (let i = 0; i < this.buffer.length; i++) {
      if (this.buffer[i] !== 0) {
        return false;
      }
    }
    return true;
  }
};

// node_modules/bittorrent-protocol/index.js
var import_crypto = __toESM(require_crypto());
var import_debug = __toESM(require_browser());
var import_rc4 = __toESM(require_rc4());
var import_streamx = __toESM(require_streamx());
var import_throughput = __toESM(require_throughput());
var import_unordered_array_remove = __toESM(require_unordered_array_remove());
var debug = (0, import_debug.default)("bittorrent-protocol");
var BITFIELD_GROW = 4e5;
var KEEP_ALIVE_TIMEOUT = 55e3;
var ALLOWED_FAST_SET_MAX_LENGTH = 100;
var MESSAGE_PROTOCOL = text2arr("BitTorrent protocol");
var MESSAGE_KEEP_ALIVE = new Uint8Array([0, 0, 0, 0]);
var MESSAGE_CHOKE = new Uint8Array([0, 0, 0, 1, 0]);
var MESSAGE_UNCHOKE = new Uint8Array([0, 0, 0, 1, 1]);
var MESSAGE_INTERESTED = new Uint8Array([0, 0, 0, 1, 2]);
var MESSAGE_UNINTERESTED = new Uint8Array([0, 0, 0, 1, 3]);
var MESSAGE_RESERVED = [0, 0, 0, 0, 0, 0, 0, 0];
var MESSAGE_PORT = [0, 0, 0, 3, 9, 0, 0];
var MESSAGE_HAVE_ALL = new Uint8Array([0, 0, 0, 1, 14]);
var MESSAGE_HAVE_NONE = new Uint8Array([0, 0, 0, 1, 15]);
var DH_PRIME = "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a36210000000000090563";
var DH_GENERATOR = 2;
var VC = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);
var CRYPTO_PROVIDE = new Uint8Array([0, 0, 1, 2]);
var CRYPTO_SELECT = new Uint8Array([0, 0, 0, 2]);
function xor(a, b) {
  for (let len = a.length; len--; ) a[len] ^= b[len];
  return a;
}
var Request = class {
  constructor(piece, offset, length, callback) {
    this.piece = piece;
    this.offset = offset;
    this.length = length;
    this.callback = callback;
  }
};
var HaveAllBitField = class {
  constructor() {
    this.buffer = new Uint8Array();
  }
  get(index) {
    return true;
  }
  set(index) {
  }
};
var Wire = class extends import_streamx.Duplex {
  constructor(type = null, retries = 0, peEnabled = false) {
    super();
    this._debugId = arr2hex(randomBytes(4));
    this._debug("new wire");
    this.peerId = null;
    this.peerIdBuffer = null;
    this.type = type;
    this.amChoking = true;
    this.amInterested = false;
    this.peerChoking = true;
    this.peerInterested = false;
    this.peerPieces = new BitField(0, { grow: BITFIELD_GROW });
    this.extensions = {};
    this.peerExtensions = {};
    this.requests = [];
    this.peerRequests = [];
    this.extendedMapping = {};
    this.peerExtendedMapping = {};
    this.extendedHandshake = {};
    this.peerExtendedHandshake = {};
    this.hasFast = false;
    this.allowedFastSet = [];
    this.peerAllowedFastSet = [];
    this._ext = {};
    this._nextExt = 1;
    this.uploaded = 0;
    this.downloaded = 0;
    this.uploadSpeed = (0, import_throughput.default)();
    this.downloadSpeed = (0, import_throughput.default)();
    this._keepAliveInterval = null;
    this._timeout = null;
    this._timeoutMs = 0;
    this._timeoutExpiresAt = null;
    this._finished = false;
    this._parserSize = 0;
    this._parser = null;
    this._buffer = [];
    this._bufferSize = 0;
    this._peEnabled = peEnabled;
    if (peEnabled) {
      this._dh = import_crypto.default.createDiffieHellman(DH_PRIME, "hex", DH_GENERATOR);
      this._myPubKey = this._dh.generateKeys("hex");
    } else {
      this._myPubKey = null;
    }
    this._peerPubKey = null;
    this._sharedSecret = null;
    this._peerCryptoProvide = [];
    this._cryptoHandshakeDone = false;
    this._cryptoSyncPattern = null;
    this._waitMaxBytes = null;
    this._encryptionMethod = null;
    this._encryptGenerator = null;
    this._decryptGenerator = null;
    this._setGenerators = false;
    this.once("finish", () => this._onFinish());
    this.on("finish", this._onFinish);
    this._debug("type:", this.type);
    if (this.type === "tcpIncoming" && this._peEnabled) {
      this._determineHandshakeType();
    } else if (this.type === "tcpOutgoing" && this._peEnabled && retries === 0) {
      this._parsePe2();
    } else {
      this._parseHandshake(null);
    }
  }
  /**
   * Set whether to send a "keep-alive" ping (sent every 55s)
   * @param {boolean} enable
   */
  setKeepAlive(enable) {
    this._debug("setKeepAlive %s", enable);
    clearInterval(this._keepAliveInterval);
    if (enable === false) return;
    this._keepAliveInterval = setInterval(() => {
      this.keepAlive();
    }, KEEP_ALIVE_TIMEOUT);
  }
  /**
   * Set the amount of time to wait before considering a request to be "timed out"
   * @param {number} ms
   * @param {boolean=} unref (should the timer be unref'd? default: false)
   */
  setTimeout(ms, unref) {
    this._debug("setTimeout ms=%d unref=%s", ms, unref);
    this._timeoutMs = ms;
    this._timeoutUnref = !!unref;
    this._resetTimeout(true);
  }
  destroy() {
    if (this.destroyed) return;
    this._debug("destroy");
    this.end();
    return this;
  }
  end(data) {
    if (this.destroyed || this.destroying) return;
    this._debug("end");
    this._onUninterested();
    this._onChoke();
    return super.end(data);
  }
  /**
   * Use the specified protocol extension.
   * @param  {function} Extension
   */
  use(Extension) {
    const name = Extension.prototype.name;
    if (!name) {
      throw new Error('Extension class requires a "name" property on the prototype');
    }
    this._debug("use extension.name=%s", name);
    const ext = this._nextExt;
    const handler = new Extension(this);
    function noop() {
    }
    if (typeof handler.onHandshake !== "function") {
      handler.onHandshake = noop;
    }
    if (typeof handler.onExtendedHandshake !== "function") {
      handler.onExtendedHandshake = noop;
    }
    if (typeof handler.onMessage !== "function") {
      handler.onMessage = noop;
    }
    this.extendedMapping[ext] = name;
    this._ext[name] = handler;
    this[name] = handler;
    this._nextExt += 1;
  }
  //
  // OUTGOING MESSAGES
  //
  /**
   * Message "keep-alive": <len=0000>
   */
  keepAlive() {
    this._debug("keep-alive");
    this._push(MESSAGE_KEEP_ALIVE);
  }
  sendPe1() {
    if (this._peEnabled) {
      const padALen = Math.floor(Math.random() * 513);
      const padA = randomBytes(padALen);
      this._push(concat([hex2arr(this._myPubKey), padA]));
    }
  }
  sendPe2() {
    const padBLen = Math.floor(Math.random() * 513);
    const padB = randomBytes(padBLen);
    this._push(concat([hex2arr(this._myPubKey), padB]));
  }
  async sendPe3(infoHash) {
    await this.setEncrypt(this._sharedSecret, infoHash);
    const hash1Buffer = await hash(hex2arr(this._utfToHex("req1") + this._sharedSecret));
    const hash2Buffer = await hash(hex2arr(this._utfToHex("req2") + infoHash));
    const hash3Buffer = await hash(hex2arr(this._utfToHex("req3") + this._sharedSecret));
    const hashesXorBuffer = xor(hash2Buffer, hash3Buffer);
    const padCLen = new DataView(randomBytes(2).buffer).getUint16(0) % 512;
    const padCBuffer = randomBytes(padCLen);
    let vcAndProvideBuffer = new Uint8Array(8 + 4 + 2 + padCLen + 2);
    vcAndProvideBuffer.set(VC);
    vcAndProvideBuffer.set(CRYPTO_PROVIDE, 8);
    const view = new DataView(vcAndProvideBuffer.buffer);
    view.setInt16(12, padCLen);
    padCBuffer.copy(vcAndProvideBuffer, 14);
    view.setInt16(14 + padCLen, 0);
    vcAndProvideBuffer = this._encryptHandshake(vcAndProvideBuffer);
    this._push(concat([hash1Buffer, hashesXorBuffer, vcAndProvideBuffer]));
  }
  async sendPe4(infoHash) {
    await this.setEncrypt(this._sharedSecret, infoHash);
    const padDLen = new DataView(randomBytes(2).buffer).getUint16(0) % 512;
    const padDBuffer = randomBytes(padDLen);
    let vcAndSelectBuffer = new Uint8Array(8 + 4 + 2 + padDLen);
    const view = new DataView(vcAndSelectBuffer.buffer);
    vcAndSelectBuffer.set(VC);
    vcAndSelectBuffer.set(CRYPTO_SELECT, 8);
    view.setInt16(12, padDLen);
    vcAndSelectBuffer.set(padDBuffer, 14);
    vcAndSelectBuffer = this._encryptHandshake(vcAndSelectBuffer);
    this._push(vcAndSelectBuffer);
    this._cryptoHandshakeDone = true;
    this._debug("completed crypto handshake");
  }
  /**
   * Message: "handshake" <pstrlen><pstr><reserved><info_hash><peer_id>
   * @param  {Uint8Array|string} infoHash (as Buffer or *hex* string)
   * @param  {Uint8Array|string} peerId
   * @param  {Object} extensions
   */
  handshake(infoHash, peerId, extensions) {
    let infoHashBuffer;
    let peerIdBuffer;
    if (typeof infoHash === "string") {
      infoHash = infoHash.toLowerCase();
      infoHashBuffer = hex2arr(infoHash);
    } else {
      infoHashBuffer = infoHash;
      infoHash = arr2hex(infoHashBuffer);
    }
    if (typeof peerId === "string") {
      peerIdBuffer = hex2arr(peerId);
    } else {
      peerIdBuffer = peerId;
      peerId = arr2hex(peerIdBuffer);
    }
    this._infoHash = infoHashBuffer;
    if (infoHashBuffer.length !== 20 || peerIdBuffer.length !== 20) {
      throw new Error("infoHash and peerId MUST have length 20");
    }
    this._debug("handshake i=%s p=%s exts=%o", infoHash, peerId, extensions);
    const reserved = new Uint8Array(MESSAGE_RESERVED);
    this.extensions = {
      extended: true,
      dht: !!(extensions && extensions.dht),
      fast: !!(extensions && extensions.fast)
    };
    reserved[5] |= 16;
    if (this.extensions.dht) reserved[7] |= 1;
    if (this.extensions.fast) reserved[7] |= 4;
    if (this.extensions.fast && this.peerExtensions.fast) {
      this._debug("fast extension is enabled");
      this.hasFast = true;
    }
    this._push(concat([MESSAGE_PROTOCOL, reserved, infoHashBuffer, peerIdBuffer]));
    this._handshakeSent = true;
    if (this.peerExtensions.extended && !this._extendedHandshakeSent) {
      this._sendExtendedHandshake();
    }
  }
  /* Peer supports BEP-0010, send extended handshake.
   *
   * This comes after the 'handshake' event to give the user a chance to populate
   * `this.extendedHandshake` and `this.extendedMapping` before the extended handshake
   * is sent to the remote peer.
   */
  _sendExtendedHandshake() {
    const msg = Object.assign({}, this.extendedHandshake);
    msg.m = {};
    for (const ext in this.extendedMapping) {
      const name = this.extendedMapping[ext];
      msg.m[name] = Number(ext);
    }
    this.extended(0, bencode_default.encode(msg));
    this._extendedHandshakeSent = true;
  }
  /**
   * Message "choke": <len=0001><id=0>
   */
  choke() {
    if (this.amChoking) return;
    this.amChoking = true;
    this._debug("choke");
    this._push(MESSAGE_CHOKE);
    if (this.hasFast) {
      let allowedCount = 0;
      while (this.peerRequests.length > allowedCount) {
        const request = this.peerRequests[allowedCount];
        if (this.allowedFastSet.includes(request.piece)) {
          ++allowedCount;
        } else {
          this.reject(request.piece, request.offset, request.length);
        }
      }
    } else {
      while (this.peerRequests.length) {
        this.peerRequests.pop();
      }
    }
  }
  /**
   * Message "unchoke": <len=0001><id=1>
   */
  unchoke() {
    if (!this.amChoking) return;
    this.amChoking = false;
    this._debug("unchoke");
    this._push(MESSAGE_UNCHOKE);
  }
  /**
   * Message "interested": <len=0001><id=2>
   */
  interested() {
    if (this.amInterested) return;
    this.amInterested = true;
    this._debug("interested");
    this._push(MESSAGE_INTERESTED);
  }
  /**
   * Message "uninterested": <len=0001><id=3>
   */
  uninterested() {
    if (!this.amInterested) return;
    this.amInterested = false;
    this._debug("uninterested");
    this._push(MESSAGE_UNINTERESTED);
  }
  /**
   * Message "have": <len=0005><id=4><piece index>
   * @param  {number} index
   */
  have(index) {
    this._debug("have %d", index);
    this._message(4, [index], null);
  }
  /**
   * Message "bitfield": <len=0001+X><id=5><bitfield>
   * @param  {BitField|Buffer} bitfield
   */
  bitfield(bitfield) {
    this._debug("bitfield");
    if (!ArrayBuffer.isView(bitfield)) bitfield = bitfield.buffer;
    this._message(5, [], bitfield);
  }
  /**
   * Message "request": <len=0013><id=6><index><begin><length>
   * @param  {number}   index
   * @param  {number}   offset
   * @param  {number}   length
   * @param  {function} cb
   */
  request(index, offset, length, cb) {
    if (!cb) cb = () => {
    };
    if (this._finished) return cb(new Error("wire is closed"));
    if (this.peerChoking && !(this.hasFast && this.peerAllowedFastSet.includes(index))) {
      return cb(new Error("peer is choking"));
    }
    this._debug("request index=%d offset=%d length=%d", index, offset, length);
    this.requests.push(new Request(index, offset, length, cb));
    if (!this._timeout) {
      this._resetTimeout(true);
    }
    this._message(6, [index, offset, length], null);
  }
  /**
   * Message "piece": <len=0009+X><id=7><index><begin><block>
   * @param  {number} index
   * @param  {number} offset
   * @param  {Uint8Array} buffer
   */
  piece(index, offset, buffer) {
    this._debug("piece index=%d offset=%d", index, offset);
    this._message(7, [index, offset], buffer);
    this.uploaded += buffer.length;
    this.uploadSpeed(buffer.length);
    this.emit("upload", buffer.length);
  }
  /**
   * Message "cancel": <len=0013><id=8><index><begin><length>
   * @param  {number} index
   * @param  {number} offset
   * @param  {number} length
   */
  cancel(index, offset, length) {
    this._debug("cancel index=%d offset=%d length=%d", index, offset, length);
    this._callback(
      this._pull(this.requests, index, offset, length),
      new Error("request was cancelled"),
      null
    );
    this._message(8, [index, offset, length], null);
  }
  /**
   * Message: "port" <len=0003><id=9><listen-port>
   * @param {Number} port
   */
  port(port) {
    this._debug("port %d", port);
    const message = new Uint8Array(MESSAGE_PORT);
    const view = new DataView(message.buffer);
    view.setUint16(5, port);
    this._push(message);
  }
  /**
   * Message: "suggest" <len=0x0005><id=0x0D><piece index> (BEP6)
   * @param {number} index
   */
  suggest(index) {
    if (!this.hasFast) throw Error("fast extension is disabled");
    this._debug("suggest %d", index);
    this._message(13, [index], null);
  }
  /**
   * Message: "have-all" <len=0x0001><id=0x0E> (BEP6)
   */
  haveAll() {
    if (!this.hasFast) throw Error("fast extension is disabled");
    this._debug("have-all");
    this._push(MESSAGE_HAVE_ALL);
  }
  /**
   * Message: "have-none" <len=0x0001><id=0x0F> (BEP6)
   */
  haveNone() {
    if (!this.hasFast) throw Error("fast extension is disabled");
    this._debug("have-none");
    this._push(MESSAGE_HAVE_NONE);
  }
  /**
   * Message "reject": <len=0x000D><id=0x10><index><offset><length> (BEP6)
   * @param  {number}   index
   * @param  {number}   offset
   * @param  {number}   length
   */
  reject(index, offset, length) {
    if (!this.hasFast) throw Error("fast extension is disabled");
    this._debug("reject index=%d offset=%d length=%d", index, offset, length);
    this._pull(this.peerRequests, index, offset, length);
    this._message(16, [index, offset, length], null);
  }
  /**
   * Message: "allowed-fast" <len=0x0005><id=0x11><piece index> (BEP6)
   * @param {number} index
   */
  allowedFast(index) {
    if (!this.hasFast) throw Error("fast extension is disabled");
    this._debug("allowed-fast %d", index);
    if (!this.allowedFastSet.includes(index)) this.allowedFastSet.push(index);
    this._message(17, [index], null);
  }
  /**
   * Message: "extended" <len=0005+X><id=20><ext-number><payload>
   * @param  {number|string} ext
   * @param  {Object} obj
   */
  extended(ext, obj) {
    this._debug("extended ext=%s", ext);
    if (typeof ext === "string" && this.peerExtendedMapping[ext]) {
      ext = this.peerExtendedMapping[ext];
    }
    if (typeof ext === "number") {
      const extId = new Uint8Array([ext]);
      const buf = ArrayBuffer.isView(obj) ? obj : bencode_default.encode(obj);
      this._message(20, [], concat([extId, buf]));
    } else {
      throw new Error(`Unrecognized extension: ${ext}`);
    }
  }
  /**
   * Sets the encryption method for this wire, as per PSE/ME specification
   *
   * @param {string} sharedSecret:  A hex-encoded string, which is the shared secret agreed
   *                                upon from DH key exchange
   * @param {string} infoHash:  A hex-encoded info hash
   * @returns boolean, true if encryption setting succeeds, false if it fails.
   */
  async setEncrypt(sharedSecret, infoHash) {
    let encryptKeyBuf;
    let encryptKeyIntArray;
    let decryptKeyBuf;
    let decryptKeyIntArray;
    switch (this.type) {
      case "tcpIncoming":
        encryptKeyBuf = await hash(hex2arr(this._utfToHex("keyB") + sharedSecret + infoHash));
        decryptKeyBuf = await hash(hex2arr(this._utfToHex("keyA") + sharedSecret + infoHash));
        encryptKeyIntArray = [];
        for (const value of encryptKeyBuf.values()) {
          encryptKeyIntArray.push(value);
        }
        decryptKeyIntArray = [];
        for (const value of decryptKeyBuf.values()) {
          decryptKeyIntArray.push(value);
        }
        this._encryptGenerator = new import_rc4.default(encryptKeyIntArray);
        this._decryptGenerator = new import_rc4.default(decryptKeyIntArray);
        break;
      case "tcpOutgoing":
        encryptKeyBuf = await hash(hex2arr(this._utfToHex("keyA") + sharedSecret + infoHash));
        decryptKeyBuf = await hash(hex2arr(this._utfToHex("keyB") + sharedSecret + infoHash));
        encryptKeyIntArray = [];
        for (const value of encryptKeyBuf.values()) {
          encryptKeyIntArray.push(value);
        }
        decryptKeyIntArray = [];
        for (const value of decryptKeyBuf.values()) {
          decryptKeyIntArray.push(value);
        }
        this._encryptGenerator = new import_rc4.default(encryptKeyIntArray);
        this._decryptGenerator = new import_rc4.default(decryptKeyIntArray);
        break;
      default:
        return false;
    }
    for (let i = 0; i < 1024; i++) {
      this._encryptGenerator.randomByte();
      this._decryptGenerator.randomByte();
    }
    this._setGenerators = true;
    return true;
  }
  /**
   * Send a message to the remote peer.
   */
  _message(id, numbers, data) {
    const dataLength = data ? data.length : 0;
    const buffer = new Uint8Array(5 + 4 * numbers.length);
    const view = new DataView(buffer.buffer);
    view.setUint32(0, buffer.length + dataLength - 4);
    buffer[4] = id;
    for (let i = 0; i < numbers.length; i++) {
      view.setUint32(5 + 4 * i, numbers[i]);
    }
    this._push(buffer);
    if (data) this._push(data);
  }
  _push(data) {
    if (this._finished) return;
    if (this._encryptionMethod === 2 && this._cryptoHandshakeDone) {
      data = this._encrypt(data);
    }
    return this.push(data);
  }
  //
  // INCOMING MESSAGES
  //
  _onKeepAlive() {
    this._debug("got keep-alive");
    this.emit("keep-alive");
  }
  _onPe1(pubKeyBuffer) {
    this._peerPubKey = arr2hex(pubKeyBuffer);
    this._sharedSecret = this._dh.computeSecret(this._peerPubKey, "hex", "hex");
    this.emit("pe1");
  }
  _onPe2(pubKeyBuffer) {
    this._peerPubKey = arr2hex(pubKeyBuffer);
    this._sharedSecret = this._dh.computeSecret(this._peerPubKey, "hex", "hex");
    this.emit("pe2");
  }
  async _onPe3(hashesXorBuffer) {
    const hash3 = await arr2hex(this._utfToHex("req3") + this._sharedSecret);
    const sKeyHash = arr2hex(xor(hash3, hashesXorBuffer));
    this.emit("pe3", sKeyHash);
  }
  _onPe3Encrypted(vcBuffer, peerProvideBuffer) {
    if (!equal(vcBuffer, VC)) {
      this._debug("Error: verification constant did not match");
      this.destroy();
      return;
    }
    for (const provideByte of peerProvideBuffer.values()) {
      if (provideByte !== 0) {
        this._peerCryptoProvide.push(provideByte);
      }
    }
    if (this._peerCryptoProvide.includes(2)) {
      this._encryptionMethod = 2;
    } else {
      this._debug("Error: RC4 encryption method not provided by peer");
      this.destroy();
    }
  }
  _onPe4(peerSelectBuffer) {
    this._encryptionMethod = peerSelectBuffer[3];
    if (!CRYPTO_PROVIDE.includes(this._encryptionMethod)) {
      this._debug("Error: peer selected invalid crypto method");
      this.destroy();
    }
    this._cryptoHandshakeDone = true;
    this._debug("crypto handshake done");
    this.emit("pe4");
  }
  _onHandshake(infoHashBuffer, peerIdBuffer, extensions) {
    const infoHash = arr2hex(infoHashBuffer);
    const peerId = arr2hex(peerIdBuffer);
    this._debug("got handshake i=%s p=%s exts=%o", infoHash, peerId, extensions);
    this.peerId = peerId;
    this.peerIdBuffer = peerIdBuffer;
    this.peerExtensions = extensions;
    if (this.extensions.fast && this.peerExtensions.fast) {
      this._debug("fast extension is enabled");
      this.hasFast = true;
    }
    this.emit("handshake", infoHash, peerId, extensions);
    for (const name in this._ext) {
      this._ext[name].onHandshake(infoHash, peerId, extensions);
    }
    if (extensions.extended && this._handshakeSent && !this._extendedHandshakeSent) {
      this._sendExtendedHandshake();
    }
  }
  _onChoke() {
    this.peerChoking = true;
    this._debug("got choke");
    this.emit("choke");
    if (!this.hasFast) {
      while (this.requests.length) {
        this._callback(this.requests.pop(), new Error("peer is choking"), null);
      }
    }
  }
  _onUnchoke() {
    this.peerChoking = false;
    this._debug("got unchoke");
    this.emit("unchoke");
  }
  _onInterested() {
    this.peerInterested = true;
    this._debug("got interested");
    this.emit("interested");
  }
  _onUninterested() {
    this.peerInterested = false;
    this._debug("got uninterested");
    this.emit("uninterested");
  }
  _onHave(index) {
    if (this.peerPieces.get(index)) return;
    this._debug("got have %d", index);
    this.peerPieces.set(index, true);
    this.emit("have", index);
  }
  _onBitField(buffer) {
    this.peerPieces = new BitField(buffer);
    this._debug("got bitfield");
    this.emit("bitfield", this.peerPieces);
  }
  _onRequest(index, offset, length) {
    if (this.amChoking && !(this.hasFast && this.allowedFastSet.includes(index))) {
      if (this.hasFast) this.reject(index, offset, length);
      return;
    }
    this._debug("got request index=%d offset=%d length=%d", index, offset, length);
    const respond = (err, buffer) => {
      if (request !== this._pull(this.peerRequests, index, offset, length)) return;
      if (err) {
        this._debug("error satisfying request index=%d offset=%d length=%d (%s)", index, offset, length, err.message);
        if (this.hasFast) this.reject(index, offset, length);
        return;
      }
      this.piece(index, offset, buffer);
    };
    const request = new Request(index, offset, length, respond);
    this.peerRequests.push(request);
    this.emit("request", index, offset, length, respond);
  }
  _onPiece(index, offset, buffer) {
    this._debug("got piece index=%d offset=%d", index, offset);
    this._callback(this._pull(this.requests, index, offset, buffer.length), null, buffer);
    this.downloaded += buffer.length;
    this.downloadSpeed(buffer.length);
    this.emit("download", buffer.length);
    this.emit("piece", index, offset, buffer);
  }
  _onCancel(index, offset, length) {
    this._debug("got cancel index=%d offset=%d length=%d", index, offset, length);
    this._pull(this.peerRequests, index, offset, length);
    this.emit("cancel", index, offset, length);
  }
  _onPort(port) {
    this._debug("got port %d", port);
    this.emit("port", port);
  }
  _onSuggest(index) {
    if (!this.hasFast) {
      this._debug("Error: got suggest whereas fast extension is disabled");
      this.destroy();
      return;
    }
    this._debug("got suggest %d", index);
    this.emit("suggest", index);
  }
  _onHaveAll() {
    if (!this.hasFast) {
      this._debug("Error: got have-all whereas fast extension is disabled");
      this.destroy();
      return;
    }
    this._debug("got have-all");
    this.peerPieces = new HaveAllBitField();
    this.emit("have-all");
  }
  _onHaveNone() {
    if (!this.hasFast) {
      this._debug("Error: got have-none whereas fast extension is disabled");
      this.destroy();
      return;
    }
    this._debug("got have-none");
    this.emit("have-none");
  }
  _onReject(index, offset, length) {
    if (!this.hasFast) {
      this._debug("Error: got reject whereas fast extension is disabled");
      this.destroy();
      return;
    }
    this._debug("got reject index=%d offset=%d length=%d", index, offset, length);
    this._callback(
      this._pull(this.requests, index, offset, length),
      new Error("request was rejected"),
      null
    );
    this.emit("reject", index, offset, length);
  }
  _onAllowedFast(index) {
    if (!this.hasFast) {
      this._debug("Error: got allowed-fast whereas fast extension is disabled");
      this.destroy();
      return;
    }
    this._debug("got allowed-fast %d", index);
    if (!this.peerAllowedFastSet.includes(index)) this.peerAllowedFastSet.push(index);
    if (this.peerAllowedFastSet.length > ALLOWED_FAST_SET_MAX_LENGTH) this.peerAllowedFastSet.shift();
    this.emit("allowed-fast", index);
  }
  _onExtended(ext, buf) {
    if (ext === 0) {
      let info;
      try {
        info = bencode_default.decode(buf);
      } catch (err) {
        this._debug("ignoring invalid extended handshake: %s", err.message || err);
      }
      if (!info) return;
      this.peerExtendedHandshake = info;
      if (typeof info.m === "object") {
        for (const name in info.m) {
          this.peerExtendedMapping[name] = Number(info.m[name].toString());
        }
      }
      for (const name in this._ext) {
        if (this.peerExtendedMapping[name]) {
          this._ext[name].onExtendedHandshake(this.peerExtendedHandshake);
        }
      }
      this._debug("got extended handshake");
      this.emit("extended", "handshake", this.peerExtendedHandshake);
    } else {
      if (this.extendedMapping[ext]) {
        ext = this.extendedMapping[ext];
        if (this._ext[ext]) {
          this._ext[ext].onMessage(buf);
        }
      }
      this._debug("got extended message ext=%s", ext);
      this.emit("extended", ext, buf);
    }
  }
  _onTimeout() {
    this._debug("request timed out");
    this._callback(this.requests.shift(), new Error("request has timed out"), null);
    this.emit("timeout");
  }
  /**
   * Duplex stream method. Called whenever the remote peer has data for us. Data that the
   * remote peer sends gets buffered (i.e. not actually processed) until the right number
   * of bytes have arrived, determined by the last call to `this._parse(number, callback)`.
   * Once enough bytes have arrived to process the message, the callback function
   * (i.e. `this._parser`) gets called with the full buffer of data.
   * @param  {Uint8Array} data
   * @param  {function} cb
   */
  _write(data, cb) {
    if (this._encryptionMethod === 2 && this._cryptoHandshakeDone) {
      data = this._decrypt(data);
    }
    this._bufferSize += data.length;
    this._buffer.push(data);
    if (this._buffer.length > 1) {
      this._buffer = [concat(this._buffer, this._bufferSize)];
    }
    if (this._cryptoSyncPattern) {
      const index = this._buffer[0].indexOf(this._cryptoSyncPattern);
      if (index !== -1) {
        this._buffer[0] = this._buffer[0].slice(index + this._cryptoSyncPattern.length);
        this._bufferSize -= index + this._cryptoSyncPattern.length;
        this._cryptoSyncPattern = null;
      } else if (this._bufferSize + data.length > this._waitMaxBytes + this._cryptoSyncPattern.length) {
        this._debug("Error: could not resynchronize");
        this.destroy();
        return;
      }
    }
    while (this._bufferSize >= this._parserSize && !this._cryptoSyncPattern) {
      if (this._parserSize === 0) {
        this._parser(new Uint8Array());
      } else {
        const buffer = this._buffer[0];
        this._bufferSize -= this._parserSize;
        this._buffer = this._bufferSize ? [buffer.slice(this._parserSize)] : [];
        this._parser(buffer.slice(0, this._parserSize));
      }
    }
    cb(null);
  }
  _callback(request, err, buffer) {
    if (!request) return;
    this._resetTimeout(!this.peerChoking && !this._finished);
    request.callback(err, buffer);
  }
  _resetTimeout(setAgain) {
    if (!setAgain || !this._timeoutMs || !this.requests.length) {
      clearTimeout(this._timeout);
      this._timeout = null;
      this._timeoutExpiresAt = null;
      return;
    }
    const timeoutExpiresAt = Date.now() + this._timeoutMs;
    if (this._timeout) {
      if (timeoutExpiresAt - this._timeoutExpiresAt < this._timeoutMs * 0.05) {
        return;
      }
      clearTimeout(this._timeout);
    }
    this._timeoutExpiresAt = timeoutExpiresAt;
    this._timeout = setTimeout(() => this._onTimeout(), this._timeoutMs);
    if (this._timeoutUnref && this._timeout.unref) this._timeout.unref();
  }
  /**
   * Takes a number of bytes that the local peer is waiting to receive from the remote peer
   * in order to parse a complete message, and a callback function to be called once enough
   * bytes have arrived.
   * @param  {number} size
   * @param  {function} parser
   */
  _parse(size, parser) {
    this._parserSize = size;
    this._parser = parser;
  }
  _parseUntil(pattern, maxBytes) {
    this._cryptoSyncPattern = pattern;
    this._waitMaxBytes = maxBytes;
  }
  /**
   * Handle the first 4 bytes of a message, to determine the length of bytes that must be
   * waited for in order to have the whole message.
   * @param  {Uint8Array} buffer
   */
  _onMessageLength(buffer) {
    const length = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength).getUint32(0);
    if (length > 0) {
      this._parse(length, this._onMessage);
    } else {
      this._onKeepAlive();
      this._parse(4, this._onMessageLength);
    }
  }
  /**
   * Handle a message from the remote peer.
   * @param  {Uint8Array} buffer
   */
  _onMessage(buffer) {
    this._parse(4, this._onMessageLength);
    const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
    switch (buffer[0]) {
      case 0:
        return this._onChoke();
      case 1:
        return this._onUnchoke();
      case 2:
        return this._onInterested();
      case 3:
        return this._onUninterested();
      case 4:
        return this._onHave(view.getUint32(1));
      case 5:
        return this._onBitField(buffer.slice(1));
      case 6:
        return this._onRequest(
          view.getUint32(1),
          view.getUint32(5),
          view.getUint32(9)
        );
      case 7:
        return this._onPiece(
          view.getUint32(1),
          view.getUint32(5),
          buffer.slice(9)
        );
      case 8:
        return this._onCancel(
          view.getUint32(1),
          view.getUint32(5),
          view.getUint32(9)
        );
      case 9:
        return this._onPort(view.getUint16(1));
      case 13:
        return this._onSuggest(view.getUint32(1));
      case 14:
        return this._onHaveAll();
      case 15:
        return this._onHaveNone();
      case 16:
        return this._onReject(
          view.getUint32(1),
          view.getUint32(5),
          view.getUint32(9)
        );
      case 17:
        return this._onAllowedFast(view.getUint32(1));
      case 20:
        return this._onExtended(buffer[1], buffer.slice(2));
      default:
        this._debug("got unknown message");
        return this.emit("unknownmessage", buffer);
    }
  }
  _determineHandshakeType() {
    this._parse(1, (pstrLenBuffer) => {
      const pstrlen = pstrLenBuffer[0];
      if (pstrlen === 19) {
        this._parse(pstrlen + 48, this._onHandshakeBuffer);
      } else {
        this._parsePe1(pstrLenBuffer);
      }
    });
  }
  _parsePe1(pubKeyPrefix) {
    this._parse(95, (pubKeySuffix) => {
      this._onPe1(concat([pubKeyPrefix, pubKeySuffix]));
      this._parsePe3();
    });
  }
  _parsePe2() {
    this._parse(96, (pubKey) => {
      this._onPe2(pubKey);
      while (!this._setGenerators) {
      }
      this._parsePe4();
    });
  }
  // Handles the unencrypted portion of step 4
  async _parsePe3() {
    const hash1Buffer = await hash(hex2arr(this._utfToHex("req1") + this._sharedSecret));
    this._parseUntil(hash1Buffer, 512);
    this._parse(20, (buffer) => {
      this._onPe3(buffer);
      while (!this._setGenerators) {
      }
      this._parsePe3Encrypted();
    });
  }
  _parsePe3Encrypted() {
    this._parse(14, (buffer) => {
      const vcBuffer = this._decryptHandshake(buffer.slice(0, 8));
      const peerProvideBuffer = this._decryptHandshake(buffer.slice(8, 12));
      const padCLen = new DataView(this._decryptHandshake(buffer.slice(12, 14)).buffer).getUint16(0);
      this._parse(padCLen, (padCBuffer) => {
        padCBuffer = this._decryptHandshake(padCBuffer);
        this._parse(2, (iaLenBuf) => {
          const iaLen = new DataView(this._decryptHandshake(iaLenBuf).buffer).getUint16(0);
          this._parse(iaLen, (iaBuffer) => {
            iaBuffer = this._decryptHandshake(iaBuffer);
            this._onPe3Encrypted(vcBuffer, peerProvideBuffer, padCBuffer, iaBuffer);
            const pstrlen = iaLen ? iaBuffer[0] : null;
            const protocol = iaLen ? iaBuffer.slice(1, 20) : null;
            if (pstrlen === 19 && arr2text(protocol) === "BitTorrent protocol") {
              this._onHandshakeBuffer(iaBuffer.slice(1));
            } else {
              this._parseHandshake();
            }
          });
        });
      });
    });
  }
  _parsePe4() {
    const vcBufferEncrypted = this._decryptHandshake(VC);
    this._parseUntil(vcBufferEncrypted, 512);
    this._parse(6, (buffer) => {
      const peerSelectBuffer = this._decryptHandshake(buffer.slice(0, 4));
      const padDLen = new DataView(this._decryptHandshake(buffer.slice(4, 6)).buffer).getUint16(0);
      this._parse(padDLen, (padDBuf) => {
        this._decryptHandshake(padDBuf);
        this._onPe4(peerSelectBuffer);
        this._parseHandshake(null);
      });
    });
  }
  /**
   * Reads the handshake as specified by the bittorrent wire protocol.
   */
  _parseHandshake() {
    this._parse(1, (buffer) => {
      const pstrlen = buffer[0];
      if (pstrlen !== 19) {
        this._debug("Error: wire not speaking BitTorrent protocol (%s)", pstrlen.toString());
        this.end();
        return;
      }
      this._parse(pstrlen + 48, this._onHandshakeBuffer);
    });
  }
  _onHandshakeBuffer(handshake) {
    const protocol = handshake.slice(0, 19);
    if (arr2text(protocol) !== "BitTorrent protocol") {
      this._debug("Error: wire not speaking BitTorrent protocol (%s)", arr2text(protocol));
      this.end();
      return;
    }
    handshake = handshake.slice(19);
    this._onHandshake(handshake.slice(8, 28), handshake.slice(28, 48), {
      dht: !!(handshake[7] & 1),
      // see bep_0005
      fast: !!(handshake[7] & 4),
      // see bep_0006
      extended: !!(handshake[5] & 16)
      // see bep_0010
    });
    this._parse(4, this._onMessageLength);
  }
  _onFinish() {
    this._finished = true;
    this.push(null);
    while (this.read()) {
    }
    clearInterval(this._keepAliveInterval);
    this._parse(Number.MAX_VALUE, () => {
    });
    while (this.peerRequests.length) {
      this.peerRequests.pop();
    }
    while (this.requests.length) {
      this._callback(this.requests.pop(), new Error("wire was closed"), null);
    }
  }
  _debug(...args) {
    args[0] = `[${this._debugId}] ${args[0]}`;
    debug(...args);
  }
  _pull(requests, piece, offset, length) {
    for (let i = 0; i < requests.length; i++) {
      const req = requests[i];
      if (req.piece === piece && req.offset === offset && req.length === length) {
        (0, import_unordered_array_remove.default)(requests, i);
        return req;
      }
    }
    return null;
  }
  _encryptHandshake(buf) {
    const crypt = new Uint8Array(buf);
    if (!this._encryptGenerator) {
      this._debug("Warning: Encrypting without any generator");
      return crypt;
    }
    for (let i = 0; i < buf.length; i++) {
      const keystream = this._encryptGenerator.randomByte();
      crypt[i] = crypt[i] ^ keystream;
    }
    return crypt;
  }
  _encrypt(buf) {
    const crypt = new Uint8Array(buf);
    if (!this._encryptGenerator || this._encryptionMethod !== 2) {
      return crypt;
    }
    for (let i = 0; i < buf.length; i++) {
      const keystream = this._encryptGenerator.randomByte();
      crypt[i] = crypt[i] ^ keystream;
    }
    return crypt;
  }
  _decryptHandshake(buf) {
    const decrypt = new Uint8Array(buf);
    if (!this._decryptGenerator) {
      this._debug("Warning: Decrypting without any generator");
      return decrypt;
    }
    for (let i = 0; i < buf.length; i++) {
      const keystream = this._decryptGenerator.randomByte();
      decrypt[i] = decrypt[i] ^ keystream;
    }
    return decrypt;
  }
  _decrypt(buf) {
    const decrypt = new Uint8Array(buf);
    if (!this._decryptGenerator || this._encryptionMethod !== 2) {
      return decrypt;
    }
    for (let i = 0; i < buf.length; i++) {
      const keystream = this._decryptGenerator.randomByte();
      decrypt[i] = decrypt[i] ^ keystream;
    }
    return decrypt;
  }
  _utfToHex(str) {
    return arr2hex(text2arr(str));
  }
};
var bittorrent_protocol_default = Wire;

// node_modules/webtorrent/lib/peer.js
var CONNECT_TIMEOUT_TCP = 5e3;
var CONNECT_TIMEOUT_UTP = 5e3;
var CONNECT_TIMEOUT_WEBRTC = 25e3;
var HANDSHAKE_TIMEOUT = 25e3;
var TYPE_TCP_INCOMING = "tcpIncoming";
var TYPE_TCP_OUTGOING = "tcpOutgoing";
var TYPE_UTP_INCOMING = "utpIncoming";
var TYPE_UTP_OUTGOING = "utpOutgoing";
var TYPE_WEBRTC = "webrtc";
var TYPE_WEBSEED = "webSeed";
var SOURCE_MANUAL = "manual";
var SOURCE_TRACKER = "tracker";
var SOURCE_DHT = "dht";
var SOURCE_LSD = "lsd";
var SOURCE_UT_PEX = "ut_pex";
var debug2 = (0, import_debug2.default)("webtorrent:peer");
var secure = false;
var enableSecure = () => {
  secure = true;
};
var Peer = class extends import_events.default {
  constructor(id, type) {
    super();
    this.id = id;
    this.type = type;
    debug2("new %s Peer %s", type, id);
    this.addr = null;
    this.conn = null;
    this.swarm = null;
    this.wire = null;
    this.source = null;
    this.connected = false;
    this.destroyed = false;
    this.timeout = null;
    this.retries = 0;
    this.sentPe1 = false;
    this.sentPe2 = false;
    this.sentPe3 = false;
    this.sentPe4 = false;
    this.sentHandshake = false;
  }
  /**
   * Called once the peer is connected (i.e. fired 'connect' event)
   * @param {Socket} conn
   */
  onConnect() {
    if (this.destroyed) return;
    this.connected = true;
    debug2("Peer %s connected", this.id);
    clearTimeout(this.connectTimeout);
    const conn = this.conn;
    conn.once("end", () => {
      this.destroy();
    });
    conn.once("close", () => {
      this.destroy();
    });
    conn.once("finish", () => {
      this.destroy();
    });
    conn.once("error", (err) => {
      this.destroy(err);
    });
    const wire = this.wire = new bittorrent_protocol_default(this.type, this.retries, secure);
    wire.once("end", () => {
      this.destroy();
    });
    wire.once("close", () => {
      this.destroy();
    });
    wire.once("finish", () => {
      this.destroy();
    });
    wire.once("error", (err) => {
      this.destroy(err);
    });
    wire.once("pe1", () => {
      this.onPe1();
    });
    wire.once("pe2", () => {
      this.onPe2();
    });
    wire.once("pe3", () => {
      this.onPe3();
    });
    wire.once("pe4", () => {
      this.onPe4();
    });
    wire.once("handshake", (infoHash, peerId) => {
      this.onHandshake(infoHash, peerId);
    });
    this.startHandshakeTimeout();
    this.setThrottlePipes();
    if (this.swarm) {
      if (this.type === "tcpOutgoing") {
        if (secure && this.retries === 0 && !this.sentPe1) this.sendPe1();
        else if (!this.sentHandshake) this.handshake();
      } else if (this.type !== "tcpIncoming" && !this.sentHandshake) this.handshake();
    }
  }
  sendPe1() {
    this.wire.sendPe1();
    this.sentPe1 = true;
  }
  onPe1() {
    this.sendPe2();
  }
  sendPe2() {
    this.wire.sendPe2();
    this.sentPe2 = true;
  }
  onPe2() {
    this.sendPe3();
  }
  sendPe3() {
    this.wire.sendPe3(this.swarm.infoHash);
    this.sentPe3 = true;
  }
  onPe3(infoHashHash) {
    if (this.swarm) {
      if (this.swarm.infoHashHash !== infoHashHash) {
        this.destroy(new Error("unexpected crypto handshake info hash for this swarm"));
      }
      this.sendPe4();
    }
  }
  sendPe4() {
    this.wire.sendPe4(this.swarm.infoHash);
    this.sentPe4 = true;
  }
  onPe4() {
    if (!this.sentHandshake) this.handshake();
  }
  clearPipes() {
    this.conn.unpipe();
    this.wire.unpipe();
  }
  setThrottlePipes() {
    const self2 = this;
    (0, import_streamx2.pipeline)(
      this.conn,
      this.throttleGroups.down.throttle(),
      new import_streamx2.Transform({
        transform(chunk, callback) {
          self2.emit("download", chunk.length);
          if (self2.destroyed) return;
          callback(null, chunk);
        }
      }),
      this.wire,
      this.throttleGroups.up.throttle(),
      new import_streamx2.Transform({
        transform(chunk, callback) {
          self2.emit("upload", chunk.length);
          if (self2.destroyed) return;
          callback(null, chunk);
        }
      }),
      this.conn
    );
  }
  /**
   * Called when handshake is received from remote peer.
   * @param {string} infoHash
   * @param {string} peerId
   */
  onHandshake(infoHash, peerId) {
    if (!this.swarm) return;
    if (this.destroyed) return;
    if (this.swarm.destroyed) {
      return this.destroy(new Error("swarm already destroyed"));
    }
    if (infoHash !== this.swarm.infoHash) {
      return this.destroy(new Error("unexpected handshake info hash for this swarm"));
    }
    if (peerId === this.swarm.peerId) {
      return this.destroy(new Error("refusing to connect to ourselves"));
    }
    debug2("Peer %s got handshake %s", this.id, infoHash);
    clearTimeout(this.handshakeTimeout);
    this.retries = 0;
    let addr = this.addr;
    if (!addr && this.conn.remoteAddress && this.conn.remotePort) {
      addr = `${this.conn.remoteAddress}:${this.conn.remotePort}`;
    }
    this.swarm._onWire(this.wire, addr);
    if (!this.swarm || this.swarm.destroyed) return;
    if (!this.sentHandshake) this.handshake();
  }
  handshake() {
    const opts = {
      dht: this.swarm.private ? false : !!this.swarm.client.dht,
      fast: true
    };
    this.wire.handshake(this.swarm.infoHash, this.swarm.client.peerId, opts);
    this.sentHandshake = true;
  }
  startConnectTimeout() {
    clearTimeout(this.connectTimeout);
    const connectTimeoutValues = {
      webrtc: CONNECT_TIMEOUT_WEBRTC,
      tcpOutgoing: CONNECT_TIMEOUT_TCP,
      utpOutgoing: CONNECT_TIMEOUT_UTP
    };
    this.connectTimeout = setTimeout(() => {
      this.destroy(new Error("connect timeout"));
    }, connectTimeoutValues[this.type]);
    if (this.connectTimeout.unref) this.connectTimeout.unref();
  }
  startHandshakeTimeout() {
    clearTimeout(this.handshakeTimeout);
    this.handshakeTimeout = setTimeout(() => {
      this.destroy(new Error("handshake timeout"));
    }, HANDSHAKE_TIMEOUT);
    if (this.handshakeTimeout.unref) this.handshakeTimeout.unref();
  }
  destroy(err) {
    if (this.destroyed) return;
    this.destroyed = true;
    this.connected = false;
    debug2("destroy %s %s (error: %s)", this.type, this.id, err && (err.message || err));
    clearTimeout(this.connectTimeout);
    clearTimeout(this.handshakeTimeout);
    const swarm = this.swarm;
    const conn = this.conn;
    const wire = this.wire;
    this.swarm = null;
    this.conn = null;
    this.wire = null;
    if (swarm && wire) {
      (0, import_unordered_array_remove2.default)(swarm.wires, swarm.wires.indexOf(wire));
    }
    if (conn) {
      conn.on("error", () => {
      });
      conn.destroy();
    }
    if (wire) wire.destroy();
    if (swarm) swarm.removePeer(this.id);
  }
};
Peer.TYPE_TCP_INCOMING = TYPE_TCP_INCOMING;
Peer.TYPE_TCP_OUTGOING = TYPE_TCP_OUTGOING;
Peer.TYPE_UTP_INCOMING = TYPE_UTP_INCOMING;
Peer.TYPE_UTP_OUTGOING = TYPE_UTP_OUTGOING;
Peer.TYPE_WEBRTC = TYPE_WEBRTC;
Peer.TYPE_WEBSEED = TYPE_WEBSEED;
Peer.SOURCE_MANUAL = SOURCE_MANUAL;
Peer.SOURCE_TRACKER = SOURCE_TRACKER;
Peer.SOURCE_DHT = SOURCE_DHT;
Peer.SOURCE_LSD = SOURCE_LSD;
Peer.SOURCE_UT_PEX = SOURCE_UT_PEX;
Peer.createWebRTCPeer = (conn, swarm, throttleGroups) => {
  const peer = new Peer(conn.id, "webrtc");
  peer.conn = conn;
  peer.swarm = swarm;
  peer.throttleGroups = throttleGroups;
  if (peer.conn.connected) {
    peer.onConnect();
  } else {
    const cleanup = () => {
      peer.conn.removeListener("connect", onConnect);
      peer.conn.removeListener("error", onError);
    };
    const onConnect = () => {
      cleanup();
      peer.onConnect();
    };
    const onError = (err) => {
      cleanup();
      peer.destroy(err);
    };
    peer.conn.once("connect", onConnect);
    peer.conn.once("error", onError);
    peer.startConnectTimeout();
  }
  return peer;
};
Peer.createTCPIncomingPeer = (conn, throttleGroups) => {
  return Peer._createIncomingPeer(conn, TYPE_TCP_INCOMING, throttleGroups);
};
Peer.createUTPIncomingPeer = (conn, throttleGroups) => {
  return Peer._createIncomingPeer(conn, TYPE_UTP_INCOMING, throttleGroups);
};
Peer.createTCPOutgoingPeer = (addr, swarm, throttleGroups) => {
  return Peer._createOutgoingPeer(addr, swarm, TYPE_TCP_OUTGOING, throttleGroups);
};
Peer.createUTPOutgoingPeer = (addr, swarm, throttleGroups) => {
  return Peer._createOutgoingPeer(addr, swarm, TYPE_UTP_OUTGOING, throttleGroups);
};
Peer._createIncomingPeer = (conn, type, throttleGroups) => {
  const addr = `${conn.remoteAddress}:${conn.remotePort}`;
  const peer = new Peer(addr, type);
  peer.conn = conn;
  peer.addr = addr;
  peer.throttleGroups = throttleGroups;
  peer.onConnect();
  return peer;
};
Peer._createOutgoingPeer = (addr, swarm, type, throttleGroups) => {
  const peer = new Peer(addr, type);
  peer.addr = addr;
  peer.swarm = swarm;
  peer.throttleGroups = throttleGroups;
  return peer;
};
Peer.createWebSeedPeer = (conn, id, swarm, throttleGroups) => {
  const peer = new Peer(id, TYPE_WEBSEED);
  peer.swarm = swarm;
  peer.conn = conn;
  peer.throttleGroups = throttleGroups;
  peer.onConnect();
  return peer;
};

export {
  __commonJS,
  __export,
  __reExport,
  __toESM,
  __publicField,
  require_events,
  arr2hex,
  hex2arr,
  concat,
  arr2text,
  text2arr,
  arr2base,
  bin2hex,
  hex2bin,
  hash,
  randomBytes,
  bencode_default,
  require_browser,
  require_streamx,
  require_throughput,
  BitField,
  require_crypto,
  require_unordered_array_remove,
  bittorrent_protocol_default,
  enableSecure,
  Peer
};
/*! Bundled license information:

uint8-util/util.js:
  (* Common package for dealing with hex/string/uint8 conversions (and sha1 hashing)
  *
  * @author   Jimmy Wärting <jimmy@warting.se> (https://jimmy.warting.se/opensource)
  * @license  MIT
  *)

bittorrent-protocol/index.js:
  (*! bittorrent-protocol. MIT License. WebTorrent LLC <https://webtorrent.io/opensource> *)
*/
//# sourceMappingURL=chunk-YE6UDQJG.js.map
